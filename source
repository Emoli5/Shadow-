if not game:IsLoaded() then game.Loaded:Wait() end
--// Services and Variables
local Ver = '3.0.0'
local Players = game:GetService('Players')
local UIS = game:GetService('UserInputService')
local VUS = game:GetService('VirtualUser')
local Run = game:GetService('RunService')
local StarterGui = game:GetService('StarterGui')
local CoreGui = game:GetService('CoreGui')
local HttpSrv = game:GetService('HttpService')
local TweenSrv = game:GetService('TweenService')
local TXS = game:GetService('TextService')
local CPS = game:GetService('ContentProvider')
local RPS = game:GetService('ReplicatedStorage')
local TPS = game:GetService('TeleportService')
local Lighting = game:GetService('Lighting')

local TweenInf = TweenInfo.new
local findInStr = table.find
local User = Players.LocalPlayer
local Mouse = User:GetMouse()
local Cam = workspace.CurrentCamera
local ChatEvt = RPS.DefaultChatSystemChatEvents
local ChatBox = game.WaitForChild(User.PlayerGui, 'Chat').Frame.ChatBarParentFrame.Frame.BoxFrame.Frame.ChatBar
--\\
--// Preloaded functions
-->>> Hub Functions
local HubFunctions = {}
local function hubFunc(f) table.insert(HubFunctions, f) end
local function loadstr(str) loadstring(game:HttpGet((str), true))() end
local function Chat(str, whisper)
	local msg = str
	if whisper then msg = '/w '..whisper.Name..' '..str end
	ChatEvt.SayMessageRequest:FireServer(msg, 'All')
end
-->>> Player Functions
local function getPos()
	local pos = false
	pcall(function()
		pos = User.Character.HumanoidRootPart.CFrame
	end)
	return pos
end

local function getTeam()
	return User.TeamColor.Name
end

local function getChar(w)
	local char = User.Character or workspace:FindFirstChild(User.Name) or nil
	if not char and w then char = User.CharacterAdded:Wait() end
	return char
end

local function findInInv(Tool)
	return User.Character:FindFirstChild(Tool) or (User:FindFirstChild('Backpack') and User.Backpack:FindFirstChild(Tool)) or nil
end

local function findPlayer(str)
	str = str:lower()
	local Found = nil
	for _, Player in next, Players:GetPlayers() do
		if Player.Name:lower():match('^'..str) or Player.DisplayName:lower():match('^'..str) then
			Found = Player
			break
		end
	end
	return Found
end

local function playerName(Player)
	local un = Player.Name
	local dn = Player.DisplayName
	if un ~= dn then return un..' ('..dn..')' else return un end
end

local function goTo(p, stand)
	pcall(function()
		local char = getChar()
		char.Humanoid.Sit = false
		if typeof(p) == 'CFrame' then
			for _, v in next, char:GetDescendants() do
				if v:IsA('Part') and (v.Name == 'HumanoidRootPart' or v:FindFirstChild('RootAttachment') or v:FindFirstChild('RootJoint')) then
					v.CFrame = p
					if stand then v.CFrame = v.CFrame * CFrame.Angles(0, 0, 0) end
				end
			end
		else 
			for _, v in next, char:GetDescendants() do
				if v:IsA('Part') and (v.Name == 'HumanoidRootPart' or v:FindFirstChild('RootAttachment') or v:FindFirstChild('RootJoint')) then
					v.CFrame = p.Character.HumanoidRootPart.CFrame
					if stand then v.CFrame = v.CFrame * CFrame.Angles(0, 0, 0) end
				end
			end
		end
	end)
end
--\\
--// UI
if CoreGui:FindFirstChild('ShadowHub') then CoreGui.YmirHub:Destroy() end

local YmirHub = Instance.new('ScreenGui')
YmirHub.Name = 'ShadowHub'
YmirHub.Parent = CoreGui
YmirHub.ResetOnSpawn = false
YmirHub.Enabled = false

local MainUI = Instance.new('ImageLabel')
MainUI.Name = 'MainUI'
MainUI.Parent = ShadowHub
MainUI.AnchorPoint = Vector2.new(.5, .5)
MainUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MainUI.BackgroundTransparency = 1
MainUI.ClipsDescendants = true
MainUI.Position = UDim2.new(.484822065, 0, .497939557, 0)
MainUI.Size = UDim2.new(0, 185, 0, 225)
MainUI.Image = 'rbxassetid://3570695787'
MainUI.ImageColor3 = Color3.fromRGB(26, 26, 26)
MainUI.ScaleType = Enum.ScaleType.Slice
MainUI.SliceCenter = Rect.new(100, 100, 100, 100)
MainUI.SliceScale = .040

local SearchBarUI = Instance.new('ImageLabel')
SearchBarUI.Name = 'SearchBarUI'
SearchBarUI.Parent = MainUI
SearchBarUI.Active = true
SearchBarUI.AnchorPoint = Vector2.new(.5, .5)
SearchBarUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SearchBarUI.BackgroundTransparency = 1
SearchBarUI.Position = UDim2.new(.570214331, 0, .186444432, 0)
SearchBarUI.Size = UDim2.new(.746571302, 0, .112999998, 0)
SearchBarUI.Image = 'rbxassetid://3570695787'
SearchBarUI.ImageColor3 = Color3.fromRGB(48, 48, 48)
SearchBarUI.ScaleType = Enum.ScaleType.Slice
SearchBarUI.SliceCenter = Rect.new(100, 100, 100, 100)
SearchBarUI.SliceScale = .080

local SearchBar = Instance.new('TextBox')
SearchBar.Name = 'SearchBar'
SearchBar.Parent = SearchBarUI
SearchBar.BackgroundColor3 = Color3.fromRGB(48, 48, 48)
SearchBar.BackgroundTransparency = 1
SearchBar.BorderSizePixel = 0
SearchBar.Position = UDim2.new(.0506897457, 0, 0, 0)
SearchBar.Size = UDim2.new(0, 132, 0, 24)
SearchBar.Font = Enum.Font.Nunito
SearchBar.PlaceholderColor3 = Color3.fromRGB(178, 178, 178)
SearchBar.PlaceholderText = 'Search or execute... '
SearchBar.ClearTextOnFocus = false
SearchBar.Text = ''
SearchBar.TextColor3 = Color3.fromRGB(255, 255, 255)
SearchBar.TextSize = 14.000
SearchBar.TextXAlignment = Enum.TextXAlignment.Left

local SearchIcon = Instance.new('ImageLabel')
SearchIcon.Name = 'SearchIcon'
SearchIcon.Parent = SearchBarUI
SearchIcon.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SearchIcon.BackgroundTransparency = 1
SearchIcon.LayoutOrder = 2
SearchIcon.Position = UDim2.new(.851000011, 0, .196999997, 0)
SearchIcon.Size = UDim2.new(0, 15, 0, 15)
SearchIcon.Image = 'http://www.roblox.com/asset/?id=12128786192'
SearchIcon.ImageColor3 = Color3.fromRGB(109, 109, 109)
SearchIcon.ScaleType = Enum.ScaleType.Fit

local TitleUI = Instance.new('TextLabel')
TitleUI.Name = 'TitleUI'
TitleUI.Parent = MainUI
TitleUI.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
TitleUI.BackgroundTransparency = 1
TitleUI.BorderSizePixel = 0
TitleUI.Position = UDim2.new(.0397726521, 0, 0, 2)
TitleUI.Size = UDim2.new(0, 177, 0, 23)
TitleUI.FontFace = Font.fromName('Nunito', Enum.FontWeight.Bold)
TitleUI.Text = 'Shadow Hub'
TitleUI.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleUI.TextSize = 16.000
TitleUI.TextWrapped = true
TitleUI.TextXAlignment = Enum.TextXAlignment.Left

local VersionUI = Instance.new('TextLabel')
VersionUI.Name = 'VersionUI'
VersionUI.Parent = MainUI
VersionUI.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
VersionUI.BackgroundTransparency = 1
VersionUI.BorderSizePixel = 0
VersionUI.Position = UDim2.new(0, 0, 0, 2)
VersionUI.Size = UDim2.new(0, 174, 0, 23)
VersionUI.FontFace = Font.fromName('Nunito', Enum.FontWeight.Bold)
VersionUI.Text = Ver
VersionUI.TextColor3 = Color3.fromRGB(255, 255, 255)
VersionUI.TextSize = 16.000
VersionUI.TextWrapped = true
VersionUI.TextXAlignment = Enum.TextXAlignment.Right

local Tabs = Instance.new('Frame')
Tabs.Name = 'Tabs'
Tabs.Parent = MainUI
Tabs.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Tabs.BackgroundTransparency = 1
Tabs.Position = UDim2.new(.0389435627, 0, .161055565, 0)
Tabs.Size = UDim2.new(0, 26, 0, 173)

local TabsHandler = Instance.new('ScrollingFrame')
TabsHandler.Name = 'TabsHandler'
TabsHandler.Parent = Tabs
TabsHandler.Active = true
TabsHandler.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TabsHandler.BackgroundTransparency = 1
TabsHandler.Size = UDim2.new(0, 26, 0, 173)
TabsHandler.CanvasSize = UDim2.new(0, 0, 0, 0)
TabsHandler.ScrollBarThickness = 0

local CmdTab = Instance.new('ImageButton')
CmdTab.Name = 'CmdTab'
CmdTab.Parent = TabsHandler
CmdTab.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
CmdTab.BackgroundTransparency = 1
CmdTab.BorderColor3 = Color3.fromRGB(255, 255, 255)
CmdTab.Size = UDim2.new(0, 20, 0, 20)
CmdTab.Image = 'http://www.roblox.com/asset/?id=12127687502'
CmdTab.ScaleType = Enum.ScaleType.Fit

local LogsTab = Instance.new('ImageButton')
LogsTab.Name = 'LogsTab'
LogsTab.Parent = TabsHandler
LogsTab.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
LogsTab.BackgroundTransparency = 1
LogsTab.LayoutOrder = 2
LogsTab.Size = UDim2.new(0, 20, 0, 20)
LogsTab.Image = 'http://www.roblox.com/asset/?id=12127870180'
LogsTab.ImageColor3 = Color3.fromRGB(109, 109, 109)
LogsTab.ScaleType = Enum.ScaleType.Fit

local NotifUI = Instance.new('ImageLabel')
NotifUI.Name = 'NotifUI'
NotifUI.Parent = LogsTab
NotifUI.Active = true
NotifUI.AnchorPoint = Vector2.new(.5, .5)
NotifUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
NotifUI.BackgroundTransparency = 1
NotifUI.BorderColor3 = Color3.fromRGB(27, 42, 53)
NotifUI.Position = UDim2.new(.8, 0, .8, 0)
NotifUI.Size = UDim2.new(.7, 0, .7, 0)
NotifUI.Image = 'rbxassetid://3570695787'
NotifUI.ImageColor3 = Color3.fromRGB(204, 41, 41)
NotifUI.ImageTransparency = 1
NotifUI.ScaleType = Enum.ScaleType.Slice
NotifUI.SliceCenter = Rect.new(100, 100, 100, 100)
NotifUI.SliceScale = .080

local Notification = Instance.new('TextLabel')
Notification.Name = 'Notification'
Notification.Parent = NotifUI
Notification.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
Notification.BackgroundTransparency = 1
Notification.BorderSizePixel = 0
Notification.Size = UDim2.new(1, 0, 1, 0)
Notification.FontFace = Font.fromName('Nunito', Enum.FontWeight.Bold)
Notification.Text = ''
Notification.TextTransparency = 1
Notification.TextColor3 = Color3.fromRGB(255, 255, 255)
Notification.TextScaled = true
Notification.TextSize = 16.000
Notification.TextWrapped = true

local SecondHandler = Instance.new('ImageLabel')
SecondHandler.Name = 'SecondHandler'
SecondHandler.Parent = MainUI
SecondHandler.Active = true
SecondHandler.AnchorPoint = Vector2.new(.5, .5)
SecondHandler.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SecondHandler.BackgroundTransparency = 1
SecondHandler.ClipsDescendants = true
SecondHandler.Position = UDim2.new(.569999993, 0, .45, 0)
SecondHandler.Size = UDim2.new(.746999979, 0, .319999993, 0)
SecondHandler.Image = 'rbxassetid://3570695787'
SecondHandler.ImageColor3 = Color3.fromRGB(40, 40, 40)
SecondHandler.ScaleType = Enum.ScaleType.Slice
SecondHandler.SliceCenter = Rect.new(100, 100, 100, 100)
SecondHandler.SliceScale = .080

local Handler = Instance.new('ImageLabel')
Handler.Name = 'Handler'
Handler.Parent = MainUI
Handler.Active = true
Handler.AnchorPoint = Vector2.new(.5, .5)
Handler.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Handler.BackgroundTransparency = 1
Handler.ClipsDescendants = true
Handler.Position = UDim2.new(.570214331, 0, .606444299, 0)
Handler.Size = UDim2.new(.746571302, 0, .650777578, 0)
Handler.Image = 'rbxassetid://3570695787'
Handler.ImageColor3 = Color3.fromRGB(48, 48, 48)
Handler.ScaleType = Enum.ScaleType.Slice
Handler.SliceCenter = Rect.new(100, 100, 100, 100)
Handler.SliceScale = .080

local Commands = Instance.new('ScrollingFrame')
Commands.Name = 'Commands'
Commands.Parent = Handler
Commands.Active = true
Commands.AutomaticCanvasSize = 'Y'
Commands.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Commands.BackgroundTransparency = 1
Commands.BorderSizePixel = 0
Commands.Position = UDim2.new(.050704062, 0, 1.04208937e-07, 0)
Commands.Size = UDim2.new(0, 131, 1, 0)
Commands.CanvasSize = UDim2.new(0, 0, 0, 0)
Commands.ScrollBarThickness = 6

local ExampleCmd = Instance.new('TextButton')
ExampleCmd.Name = 'AdminCmd'
ExampleCmd.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ExampleCmd.BackgroundTransparency = 1
ExampleCmd.Position = UDim2.new(0, 0, 1.1, 0)
ExampleCmd.Size = UDim2.new(0, 123, 0, 18)
ExampleCmd.Font = Enum.Font.Nunito
ExampleCmd.Text = ''
ExampleCmd.TextColor3 = Color3.fromRGB(255, 255, 255)
ExampleCmd.TextSize = 14.000
ExampleCmd.TextXAlignment = Enum.TextXAlignment.Left

local Description = Instance.new('ImageLabel')
Description.Name = 'Description'
Description.Parent = Handler
Description.BackgroundTransparency = 1
Description.BorderSizePixel = 0
Description.ClipsDescendants = true
Description.Position = UDim2.new(0, 0, 1.1, 0)
Description.Size = UDim2.new(1, 0, 1, 0)
Description.Image = 'rbxassetid://3570695787'
Description.ImageColor3 = Color3.fromRGB(48, 48, 48)
Description.ScaleType = Enum.ScaleType.Slice
Description.SliceCenter = Rect.new(100, 100, 100, 100)
Description.SliceScale = .080

local CloseDesc = Instance.new('ImageButton')
CloseDesc.Name = 'CloseDesc'
CloseDesc.Parent = Description
CloseDesc.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
CloseDesc.BackgroundTransparency = 1
CloseDesc.LayoutOrder = 2
CloseDesc.Position = UDim2.new(.850000024, 0, .075000003, 0)
CloseDesc.Size = UDim2.new(0, 12, 0, 12)
CloseDesc.Image = 'http://www.roblox.com/asset/?id=11678821024'
CloseDesc.ScaleType = Enum.ScaleType.Fit

local NameUI = Instance.new('TextLabel')
NameUI.Name = 'NameUI'
NameUI.Parent = Description
NameUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
NameUI.BackgroundTransparency = 1
NameUI.Position = UDim2.new(.0507245734, 0, .0547945164, 0)
NameUI.Size = UDim2.new(0, 96, 0, 25)
NameUI.FontFace = Font.fromName('Nunito', Enum.FontWeight.Bold)
NameUI.Text = ''
NameUI.TextColor3 = Color3.fromRGB(255, 255, 255)
NameUI.TextSize = 18.000
NameUI.TextXAlignment = Enum.TextXAlignment.Left

local MiniUI = Instance.new('TextLabel')
MiniUI.Name = 'MiniUI'
MiniUI.Parent = Description
MiniUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MiniUI.BackgroundTransparency = 1
MiniUI.Position = UDim2.new(.0507245734, 0, .209999979, 0)
MiniUI.Size = UDim2.new(0, 124, 0, 25)
MiniUI.FontFace = Font.fromName('Nunito', Enum.FontWeight.SemiBold)
MiniUI.LineHeight = .75
MiniUI.RichText = true
MiniUI.Text = ''
MiniUI.TextColor3 = Color3.fromRGB(178, 178, 178)
MiniUI.TextSize = 12.000
MiniUI.TextTruncate = Enum.TextTruncate.AtEnd
MiniUI.TextWrapped = true
MiniUI.TextXAlignment = Enum.TextXAlignment.Left

local DescUI = Instance.new('TextLabel')
DescUI.Name = 'DescUI'
DescUI.Parent = Description
DescUI.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
DescUI.BackgroundTransparency = 1
DescUI.LineHeight = .75
DescUI.Position = UDim2.new(.0507245734, 0, .380735904, 0)
DescUI.Size = UDim2.new(0, 127, 0, 79)
DescUI.Font = Enum.Font.Nunito
DescUI.LineHeight = 0.750
DescUI.Text = ''
DescUI.TextColor3 = Color3.fromRGB(255, 255, 255)
DescUI.TextSize = 15.000
DescUI.TextWrapped = true
DescUI.TextXAlignment = Enum.TextXAlignment.Left
DescUI.TextYAlignment = Enum.TextYAlignment.Top

local Logs = Instance.new('ScrollingFrame')
Logs.Name = 'Logs'
Logs.Parent = Handler
Logs.Active = true
Logs.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Logs.BackgroundTransparency = 1
Logs.BorderSizePixel = 0
Logs.Position = UDim2.new(.050704062, 0, 1.04208937e-07, 0)
Logs.AutomaticCanvasSize = 'Y'
Logs.Size = UDim2.new(0, 131, 1, 0)
Logs.Visible = false
Logs.CanvasSize = UDim2.new(0, 0, 0, 0)
Logs.ScrollBarThickness = 6

local ExampleLog = Instance.new('TextLabel')
ExampleLog.Name = 'AdminLog'
ExampleLog.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ExampleLog.BackgroundTransparency = 1
ExampleLog.LayoutOrder = 1
ExampleLog.LineHeight = .75
ExampleLog.Position = UDim2.new(0, 0, .0479452051, 0)
ExampleLog.Size = UDim2.new(0, 73, 0, 28)
ExampleLog.Font = Enum.Font.Nunito
ExampleLog.Text = ''
ExampleLog.TextColor3 = Color3.fromRGB(255, 255, 255)
ExampleLog.TextSize = 14.000
ExampleLog.TextWrapped = true
ExampleLog.TextXAlignment = Enum.TextXAlignment.Left
ExampleLog.TextYAlignment = Enum.TextYAlignment.Top

local Timestamp = Instance.new('TextLabel')
Timestamp.Name = 'Timestamp'
Timestamp.Parent = ExampleLog
Timestamp.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Timestamp.BackgroundTransparency = 1
Timestamp.Position = UDim2.new(.7, 0, 0, 0)
Timestamp.Size = UDim2.new(1, 0, 1, 0)
Timestamp.Font = Enum.Font.Nunito
Timestamp.Text = 'Now'
Timestamp.TextColor3 = Color3.fromRGB(178, 178, 178)
Timestamp.TextSize = 12.000
Timestamp.TextWrapped = true
Timestamp.TextXAlignment = Enum.TextXAlignment.Right
Timestamp.TextYAlignment = Enum.TextYAlignment.Center

local function Space(parent, size, order)
	local Spacing = Instance.new('Frame')
	Spacing.Name = ''
	Spacing.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Spacing.BackgroundTransparency = 1
	Spacing.Size = size or UDim2.new(0, 123, 0, 0)
	Spacing.LayoutOrder = order or 0
	Spacing.Parent = parent
end

Space(Commands)
Space(Logs)
Space(Logs, UDim2.new(0, 123, 0, 5), 999999999)

local function List(parent, padding)
	local List = Instance.new('UIListLayout')
	List.SortOrder = Enum.SortOrder.LayoutOrder
	List.Padding = padding or UDim.new(0, 0)
	List.Parent = parent
end

List(TabsHandler, UDim.new(0, 15))
List(Commands, UDim.new(0, 2))
List(Logs, UDim.new(0, 8))
--\\
--// Configs and other variables
local Path = 'YmirHubConfigs.json'

local HubSettings = {
	Prefix = '.',
	KillTool = 'AK-47',
	TPTool = 'M9',
	SplitScreen = false,
	HubPos = {x = MainUI.Position.X.Offset, y = MainUI.Position.Y.Offset},
	Whitelist = {},
	PermaRanked = {},
	AutoExecute = {}
}

local function saveSettings()
	spawn(function()
		if writefile then
			writefile(Path, HttpSrv:JSONEncode(HubSettings))
		end
	end)
end

local function loadSettings()
	if (readfile and isfile and isfile(Path)) then
		local Settings = HttpSrv:JSONDecode(readfile(Path))
		for i, v in pairs(Settings) do
			HubSettings[i] = v
		end
	end
end
loadSettings()
local Prefix = HubSettings.Prefix
local KillTool = HubSettings.KillTool
local TPTool = HubSettings.TPTool
local Whitelist = HubSettings.Whitelist
local Ranked = HubSettings.PermaRanked
local HubPos = HubSettings.HubPos
MainUI.Position = UDim2.new(0.5, HubPos.x, 0.5, HubPos.y)
--\\
--// UI Functions
-->>> Dragging
local dragToggle, dragInput, dragStart, dragPos
local dragSpeed = .25 

function Update(input)
	local delta = input.Position - dragStart
	local pos = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	TweenSrv:Create(MainUI, TweenInf(.25), {Position = pos}):Play()
	HubSettings.HubPos = {x = pos.X.Offset, y = pos.Y.Offset}
	saveSettings()
end

MainUI.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragToggle = true
		dragStart = input.Position
		startPos = MainUI.Position
		input.Changed:Connect(function()
			if (input.UserInputState == Enum.UserInputState.End) then
				dragToggle = false
			end
		end)
	end
end)

MainUI.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UIS.InputChanged:Connect(function(input)
	if input == dragInput and dragToggle then
		Update(input)
	end
end)
-->>> Tabs
Tabs:SetAttribute('CurrentTab', 'Admin')
Tabs:SetAttribute('SplitScreen', false)
SearchBar:SetAttribute('LastSearch', '')

hubFunc(Tabs:GetAttributeChangedSignal('SplitScreen'):Connect(function()
	local on = Tabs:GetAttribute('SplitScreen')
	HubSettings.SplitScreen = on
	saveSettings()
	if on then
		Logs.Parent = SecondHandler
		Logs.Visible = true
		LogsTab.ImageColor3 = Color3.fromRGB(255, 255, 255)
		if NotifUI.ImageTransparency ~= 1 then 
			NotifUI.ImageTransparency = 1
			Notification.TextTransparency = 1
			Notification.Text = ''
		end
		local t = TweenSrv:Create(Handler, TweenInf(.25), {Position = UDim2.new(.57, 0, .438, 0), Size = UDim2.new(.747, 0, .32, 0)})
		t:Play(); t.Completed:Wait()
		local t2 = TweenSrv:Create(SecondHandler, TweenInf(.25), {Position = UDim2.new(.569999993, 0, .771, 0)})
		t2:Play(); t2.Completed:Wait()
		TweenSrv:Create(SecondHandler, TweenInf(.25), {ImageColor3 = Color3.fromRGB(48, 48, 48)}):Play()
	else 
		TweenSrv:Create(LogsTab, TweenInf(.25), {ImageColor3 = Color3.fromRGB(109, 109, 109)}):Play()
		local t = TweenSrv:Create(SecondHandler, TweenInf(.25), {ImageColor3 = Color3.fromRGB(40, 40, 40)})
		t:Play(); wait(.15)
		local t2 = TweenSrv:Create(SecondHandler, TweenInf(.25), {Position = UDim2.new(.569999993, 0, .45, 0)})
		t2:Play(); t2.Completed:Wait()
		Logs.Visible = false
		Logs.Parent = Handler
		TweenSrv:Create(Handler, TweenInf(.25), {Position = UDim2.new(.570214331, 0, .606444299, 0), Size = UDim2.new(.746571302, 0, .650777578, 0)}):Play()
	end
end))

hubFunc(Tabs:GetAttributeChangedSignal('CurrentTab'):Connect(function()
	local tab = Tabs:GetAttribute('CurrentTab')
	if tab == 'Admin' then
		SearchBar.PlaceholderText = 'Execute or Search'
		SearchBar.Text = SearchBar:GetAttribute('LastSearch')
		SearchIcon.Visible = true
		CmdTab.ImageColor3 = Color3.fromRGB(255, 255, 255)
		for _, v in next, TabsHandler:GetChildren() do
			if v:IsA('ImageButton') then
				if v ~= CmdTab then 
					if Tabs:GetAttribute('SplitScreen') and v == LogsTab then continue end
					TweenSrv:Create(v, TweenInf(.25), {ImageColor3 = Color3.fromRGB(109, 109, 109)}):Play()
				end
			end
		end
		for _, v in next, Handler:GetChildren() do
			if v.Name == 'Commands' or v.Name == 'Description' then v.Visible = true else v.Visible = false end
		end
		if Description.Position ~= UDim2.new(0, 0, 1.1, 0) then
			TweenSrv:Create(Description, TweenInf(.2), {Position = UDim2.new(0, 0, 1.1, 0)}):Play()
			wait(.2)
			if Tabs:GetAttribute('SplitScreen') then
				TweenSrv:Create(LogsTab, TweenInf(.25), {ImageColor3 = Color3.fromRGB(255, 255, 255)}):Play()
				TweenSrv:Create(Handler, TweenInf(.25), {Position = UDim2.new(.57, 0, .438, 0), Size = UDim2.new(.747, 0, .32, 0)}):Play()
			end
		end
	elseif tab == 'Logs' then
		SearchBar.PlaceholderText = ''
		SearchBar:SetAttribute('LastSearch', SearchBar.Text)
		SearchBar.Text = ''
		SearchIcon.Visible = false
		LogsTab.ImageColor3 = Color3.fromRGB(255, 255, 255)
		for _, v in next, TabsHandler:GetChildren() do
			if v:IsA('ImageButton') then
				if v ~= LogsTab then 
					TweenSrv:Create(v, TweenInf(.25), {ImageColor3 = Color3.fromRGB(109, 109, 109)}):Play()
				end
			end
		end
		for _, v in next, Handler:GetChildren() do
			if v.Name == 'Logs' then v.Visible = true else v.Visible = false end
		end
		if NotifUI.ImageTransparency ~= 1 then 
			NotifUI.ImageTransparency = 1
			Notification.TextTransparency = 1
			Notification.Text = ''
		end
	elseif tab == 'Desc' then 
		for _, v in next, TabsHandler:GetChildren() do
			if v:IsA('ImageButton') then
				TweenSrv:Create(v, TweenInf(.25), {ImageColor3 = Color3.fromRGB(109, 109, 109)}):Play()
			end
		end
		if Tabs:GetAttribute('SplitScreen') then
			TweenSrv:Create(Handler, TweenInf(.25), {Position = UDim2.new(.570214331, 0, .606444299, 0), Size = UDim2.new(.746571302, 0, .650777578, 0)}):Play()
			wait(.25)
		end
		local tw = TweenSrv:Create(Description, TweenInf(.2), {Position = UDim2.new(0, 0, 0, 0)})
		tw:Play(); tw.Completed:Wait()
		Commands.Visible = false	
	end
end))

CmdTab.MouseEnter:Connect(function()
	if Tabs:GetAttribute('CurrentTab') ~= 'Admin' then
		TweenSrv:Create(CmdTab, TweenInf(.25), {ImageColor3 = Color3.fromRGB(255, 255, 255)}):Play()
	end
end)

CmdTab.MouseLeave:Connect(function()
	if Tabs:GetAttribute('CurrentTab') ~= 'Admin' then
		TweenSrv:Create(CmdTab, TweenInf(.25), {ImageColor3 = Color3.fromRGB(109, 109, 109)}):Play()
	end
end)

CmdTab.MouseButton1Click:Connect(function()
	Tabs:SetAttribute('CurrentTab', 'Admin')
end)

LogsTab.MouseEnter:Connect(function()
	if Tabs:GetAttribute('CurrentTab') ~= 'Logs' and Tabs:GetAttribute('SplitScreen') == false then
		TweenSrv:Create(LogsTab, TweenInf(.25), {ImageColor3 = Color3.fromRGB(255, 255, 255)}):Play()
	end
end)

LogsTab.MouseLeave:Connect(function()
	if Tabs:GetAttribute('CurrentTab') ~= 'Logs' and Tabs:GetAttribute('SplitScreen') == false then
		TweenSrv:Create(LogsTab, TweenInf(.25), {ImageColor3 = Color3.fromRGB(109, 109, 109)}):Play()
	end
end)

LogsTab.MouseButton1Click:Connect(function()
	if Tabs:GetAttribute('SplitScreen') == false then Tabs:SetAttribute('CurrentTab', 'Logs') end
end)

LogsTab.MouseButton2Click:Connect(function()
	if not findInStr({'Logs', 'Description'}, Tabs:GetAttribute('CurrentTab')) then
		local ss = Tabs:GetAttribute('SplitScreen')
		if ss then Tabs:SetAttribute('SplitScreen', false) else Tabs:SetAttribute('SplitScreen', true) end
	end
end)

CloseDesc.MouseButton1Click:Connect(function()
	Tabs:SetAttribute('CurrentTab', 'Admin')
end)
-->>> Logs
local function Log(text, rich)
	spawn(function()
		local clone = ExampleLog:Clone()	
		local ts = clone.Timestamp
		clone.RichText = rich or false
		clone.Text = text
		clone.TextTransparency = 1
		ts.TextTransparency = 1
		clone.Size = UDim2.fromOffset(73, math.huge)
		clone.Parent = Logs
		clone.Size = UDim2.fromOffset(73, clone.TextBounds.Y)
		Logs.CanvasPosition = Vector2.new(0, Logs.AbsoluteCanvasSize.Y)
		TweenSrv:Create(clone, TweenInf(.2), {TextTransparency = 0}):Play()
		TweenSrv:Create(ts, TweenInf(.2), {TextTransparency = 0}):Play()

		spawn(function()
			local secs = 0
			while wait(1) do
				if YmirHub.Parent == nil then break end
				secs = secs + 1
				if secs < 60 then
					clone.Timestamp.Text = secs..' sec ago'
				elseif secs < 3600 then
					local mins = secs/60
					if math.floor(mins) == mins then
						clone.Timestamp.Text = mins..' min ago'
					end
				elseif secs < 86400 then 
					local hrs = secs/3600
					if math.floor(hrs) == hrs then
						clone.Timestamp.Text = hrs..' hour ago'
					end
				end
			end
		end)

		if Tabs:GetAttribute('CurrentTab') ~= 'Logs' and Tabs:GetAttribute('SplitScreen') == false then
			wait(.5)
			TweenSrv:Create(NotifUI, TweenInf(.09), {ImageTransparency = 0}):Play()
			TweenSrv:Create(Notification, TweenInf(.09), {TextTransparency = 0}):Play()
			if Notification.Text == '' then
				Notification.Text = '1'
			else
				local text = Notification.Text
				if text ~= '99+' then
					if tonumber(text) <= 99 then
						Notification.Text = tostring(tonumber(text) + 1)
					else
						Notification.Text = '99+'
					end
				end
			end
		end
	end)
end
--\\
--// Prison Life
-->>> Variables
local prisonItems = workspace.Prison_ITEMS
local remotes = workspace.Remote
local giver = prisonItems.giver
local single = prisonItems.single
local clothes = prisonItems.clothes
local hats = prisonItems.hats
local buttons = prisonItems.buttons
local arrestEvt = remotes.arrest
local loadChar = remotes.loadchar
local itemEvt = remotes.ItemHandler
local teamEvt = remotes.TeamEvent
local meleeEvt = RPS.meleeEvent
local shootEvt = RPS.ShootEvent
local reloadEvt = RPS.ReloadEvent
local soundEvt = RPS.SoundEvent
local Riot = game:GetService('MarketplaceService'):UserOwnsGamePassAsync(User.UserId, 96651)

local Powers = {
	LoopKilled = {},
	LoopTased = {},
	ModdedGuns = {},
	Aura = {},
	Spectating = nil,
	SpamArresting = nil
}

-->>> Aliases
local AllPlayers = {'all', 'others', 'other', 'everyone'}
local Inmates = {'inmate', 'inmates', 'prisoner', 'prisoner'}
local Guards = {'guard', 'guards', 'cop', 'cops', 'police'}
local Crims = {'criminal', 'criminals', 'crim', 'crims'}

local M9 = {'m9', 'pistol'}
local Remington = {'remington', 'remington870', 'remington-870', 'reming', 'shotgun'}
local AK47 = {'ak47', 'ak-47', 'ak'}
local M4A1 = {'m4a1', 'm4'}

-->>> Functions
local function Respawn() 
	loadChar:InvokeServer() 
	Powers.God = false
end

local Re
local function Refresh() 
	local Pos = getPos()
	Re = true
	Respawn()
	goTo(Pos)
end

local function joinTeam(Team, Ref)
	local reChar
	if type(Team) == 'string' then
		if findInStr({'Bright orange', 'Bright blue', 'Medium stone grey'}, Team) then
			if Ref then reChar = true else teamEvt:FireServer(Team) end
		else reChar = true end
	else reChar = true end
	if reChar then
		local Pos = getPos()
		loadChar:InvokeServer(nil, Team)
		goTo(Pos)
	end
end

local function getTool(Tool)
	local Team = getTeam()
	if Tool == 'Key card' then 
		if single:FindFirstChild(Tool) then itemEvt:InvokeServer(single[Tool].ITEMPICKUP)
		else 
			Powers.Keycard = true
			repeat
				local newTeam = getTeam()
				if newTeam ~= 'Bright blue' then
					joinTeam('Bright blue', true)
				end
				local char = getChar()
				if char and char:FindFirstChild('Humanoid') then
					if char.Humanoid.Health == 0 then
						Respawn()
					else char.Humanoid.Health = 0 end
				end
				Run.RenderStepped:Wait()
			until single:FindFirstChild(Tool)
			joinTeam(Team)
			itemEvt:InvokeServer(single[Tool].ITEMPICKUP)
			Powers.Keycard = false
		end
	elseif findInStr({'Hammer', 'Crude Knife'}, Tool) and Team == 'Bright blue' then
		joinTeam('Bright orange')
		itemEvt:InvokeServer(single[Tool].ITEMPICKUP)
		joinTeam(Team)
	elseif Tool == 'Riot Shield' and Team ~= 'Bright blue' then
		joinTeam('Bright blue')
		itemEvt:InvokeServer(giver[Tool].ITEMPICKUP)
	else
		if giver:FindFirstChild(Tool) then itemEvt:InvokeServer(giver[Tool].ITEMPICKUP) 
		elseif single:FindFirstChild(Tool) then itemEvt:InvokeServer(single[Tool].ITEMPICKUP) end
	end
end

local function refreshTool(Tool)
	local char = getChar()
	local Parent = Tool.Parent
	Tool.Handle:Destroy()
	Tool.Parent = char
	Tool:Destroy()
	getTool(Tool.Name)
	local newTool = findInInv(Tool.Name)
	newTool.Parent = Parent
end

local function Equip(Accessory)
	if clothes:FindFirstChild(Accessory) then itemEvt:InvokeServer(clothes[Accessory].ITEMPICKUP) 
	elseif hats:FindFirstChild(Accessory) then itemEvt:InvokeServer(hats[Accessory].ITEMPICKUP) end
end

local function createSound(sound, source, intensity)
	for i = 1, intensity do
		soundEvt:InvokeServer(sound, source)
	end
end

local function Kill(p)
	pcall(function()
		getTool(KillTool)
		local Tool = findInInv(KillTool)
		local states = require(Tool.GunStates)
		local reloadtime = states.ReloadTime
		local Event = {}
		if type(p) == 'table' then -- (Multiple players)
			for _, Player in next, p do
				local range = 10
				if Player.Character:FindFirstChild('vest') then range = 13 end
				for i = 1, range do
					Event[#Event+1] = {['RayObject'] = Ray.new(), ['Distance'] = 0, ['Cframe'] = CFrame.new(), ['Hit'] = Player.Character:FindFirstChildOfClass('Part')}
				end
			end
		else 
			local range = 10
			if p.Character:FindFirstChild('vest') then range = 13 end
			for i = 1, range do
				Event[#Event+1] = {['RayObject'] = Ray.new(), ['Distance'] = 0, ['Cframe'] = CFrame.new(), ['Hit'] = p.Character:FindFirstChildOfClass('Part')}
			end
		end
		shootEvt:FireServer(Event, Tool)
		local Team = getTeam()
		if Team ~= 'Bright blue' then
			states.ReloadTime = -math.huge
			reloadEvt:FireServer(Tool)
			states.ReloadTime = reloadtime
		else 
			Tool.Handle:Destroy()
			local char = getChar()
			Tool.Parent = char
			Tool:Destroy()
		end
	end)
end

local function Arrest(Player) 
	local counter = 0
	repeat
		counter = counter + 1
		goTo(Player)
		arrestEvt:InvokeServer(Player.Character.Head) 
		Run.Stepped:Wait()
	until (not Player or not findPlayer(Player.Name)) or Player.Character.Head:FindFirstChild('handcuffedGui') or Player.Character.Humanoid.WalkSpeed == 0 or counter > 3
end

local function touchKill()
	local p = Instance.new('Part', User.Character)
	p.Transparency = 1
	p.Size = User.Character.Torso.Size
	p.CanCollide = false
	local w = Instance.new('Weld', p)
	w.Part0 = User.Character.Torso
	w.Part1 = p
	w.C1 = CFrame.new(0, 0, 2)
	p.Touched:Connect(function(h)
		local char = h:FindFirstAncestorWhichIsA('Model')
		if char then
			local Player = findPlayer(char.Name)
			if not Kill and Player and Player ~= User and char.Humanoid.Health > 0 then
				Kill = true
				for i= 1, 15 do
					meleeEvt:FireServer(Player)
				end
			end
		end
	end)
	wait(.1)
	Kill = false
	p:Destroy()
end

local function Tase(p)
	pcall(function()
		local Tool = findInInv('Taser')
		local Event = {}

		if type(p) == 'table' then -- (Multiple players)
			for _, Player in next, p do
				Event[#Event+1] = {['RayObject'] = Ray.new(), ['Distance'] = 0, ['Cframe'] = CFrame.new(), ['Hit'] = Player.Character:FindFirstChildOfClass('Part')}
			end
		else 
			Event[#Event+1] = {['RayObject'] = Ray.new(), ['Distance'] = 0, ['Cframe'] = CFrame.new(), ['Hit'] = p.Character:FindFirstChildOfClass('Part')}
		end
		shootEvt:FireServer(Event, Tool)
		reloadEvt:FireServer(Tool)
	end)
end

local function Attach(Player, Tool, Bringing)
	local char = getChar()
	local hum = char.Humanoid
	hum.Parent = nil
	wait()
	hum.Parent = char
	Cam.CameraSubject = char
	char.Animate.Disabled = true
	wait()
	char.Animate.Disabled = false
	Tool.Parent = char
	char:SetAttribute('Attach', true)
	repeat 
		local char = getChar()
		if not char:GetAttribute('Attach') and Bringing then
			getTool(Tool.Name)
			local char = getChar()
			local hum = char.Humanoid
			hum.Parent = nil
			wait()
			hum.Parent = char
			Cam.CameraSubject = char
			char.Animate.Disabled = true
			wait()
			char.Animate.Disabled = false
			Tool.Parent = char
			char:SetAttribute('Attach', true)
		end
		goTo(Player, true)
		Run.Stepped:Wait()
	until (not Player or not findPlayer(Player.Name)) or Tool.Parent ~= char
end

local function Bring(Player, Pos)
	getTool(TPTool)
	local Tool = findInInv(TPTool)
	Attach(Player, Tool, true)
	local counter = 0
	repeat
		goTo(Pos, true)
		counter = counter + 1
		Run.Stepped:Wait()
	until (not Player or not findPlayer(Player.Name)) or counter > 59
	Refresh()
end

local function Fling(Player)
	local flung 
	local counter = 0
	repeat
		counter = counter + 1
		local char = getChar()
		local hum = char:FindFirstChild('Humanoid')
		if hum.Health <= 0 then Refresh() end
		local playing = false
		local anims = hum:GetPlayingAnimationTracks()
		for _, v in next, anims do
			if v.Animation.AnimationId == 'rbxassetid://282574440' then playing = true break end
		end

		local function anim(id)
			local Anim = Instance.new('Animation')
			Anim.AnimationId = id
			return hum:LoadAnimation(Anim)
		end

		if not playing then 
			local track = anim('rbxassetid://282574440')
			track:Play(.1, 1, 1)
		end
		goTo(Player)
		char.Humanoid.HipHeight = 1000
		local ray = Ray.new(Player.Character.HumanoidRootPart.Position,Vector3.new(0,-15,0))
		local hit = workspace:FindPartOnRay(ray)
		if not hit then flung = true end
		Run.Heartbeat:Wait()
	until (not Player or not findPlayer(Player.Name) or not Player.Character) or flung or counter > 500
end

local function MakeCrim(Player) 
	repeat
		Bring(Player, CFrame.new(-919, 96, 2138))
		Run.Heartbeat:Wait()
	until (not Player or not findPlayer(Player.Name)) or Player.TeamColor.Name == 'Really red'
end

local function God()
	local GodFunctions = {}
	local function godFunc(f) table.insert(GodFunctions, f) end

	local char = getChar()
	local hum = char.Humanoid
	User.Character = nil
	User.Character = char
	char.Torso.Anchored = true
	hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
	hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	hum.BreakJointsOnDeath = false
	hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	char.Torso.Anchored = false
	Cam.CameraSubject = hum
	char.Animate.Disabled = true
	wait()
	char.Animate.Disabled = false
	for _, v in next, char:GetDescendants() do
		if v:IsA('BasePart') then
			godFunc(Run.RenderStepped:Connect(function()
				pcall(function()
					v.Velocity = Vector3.new(0, 0, 0)
					v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
					v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
					v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
					v.Massless = true
					hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
					hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
					hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
					hum.BreakJointsOnDeath = false
				end)
			end))
		end
	end

	godFunc(Run.Heartbeat:Connect(function()
		if not Powers.God or not char or User.Character ~= char then
			Powers.God = false
			for _, v in next, GodFunctions do v:Disconnect() end
		end
	end))
end
--\\
--// Commands
-->>> Creating commands
local function createCmd(properties)
	local name = properties[1]
	local aliases = properties[2]
	local desc = properties[3]
	local args = properties[4] or nil

	local cmd = ExampleCmd:Clone()
	cmd.Name = name
	cmd.Text = name
	cmd.Parent = Commands

	if #aliases > 0 then
		local folder = Instance.new('Configuration', cmd)
		folder.Name = 'Aliases'
		for _, v in next, aliases do
			local val = Instance.new('StringValue', folder)
			val.Value = v
		end
	end

	if args and #args > 0  then
		local folder = Instance.new('Configuration', cmd)
		folder.Name = 'Arguments'
		for _, v in next, args do
			local val = Instance.new('StringValue', folder)
			val.Value = v
			if v:match('*') then val.Name = 'Required' else val.Name = 'Optional' end
		end
	end

	cmd.MouseButton1Click:Connect(function()
		SearchBar:CaptureFocus()
		SearchBar.Text = name
		if args then SearchBar.Text = name..' ' end
		SearchBar.CursorPosition = #SearchBar.Text + 1
	end)

	cmd.MouseButton2Click:Connect(function()
		SearchBar:ReleaseFocus()
		NameUI.Text = name
		if #aliases > 0 then 
			MiniUI.Text = 'aka: '
			for i, v in next, aliases do
				MiniUI.Text = MiniUI.Text..v..', '
				if #MiniUI.Text > 23 then 
					local text = MiniUI.Text:sub(1, 23)
					MiniUI.Text = text..'...'
					break
				end
			end
			if MiniUI.Text:sub(#MiniUI.Text - 2, #MiniUI.Text) ~= '...' then
				MiniUI.Text = MiniUI.Text:sub(1, #MiniUI.Text - 2)
			end
		else MiniUI.Text = '(No aliases)' end
		MiniUI.Text = MiniUI.Text..'<font size="0">\n</font>'
		if args and #args > 0 then 
			MiniUI.Text = MiniUI.Text..'args: '
			for _, v in next, args do
				if v:match('*') then v = v:gsub('*', '<font color="rgb(255,0,0)">*</font>') end
				MiniUI.Text = MiniUI.Text..v..', ' 
			end
			MiniUI.Text = MiniUI.Text:sub(1, #MiniUI.Text - 2)
		else MiniUI.Text = MiniUI.Text..'(No arguments)' end
		DescUI.Text = desc
		Tabs:SetAttribute('CurrentTab', 'Desc')
	end)

	hubFunc(Run.Heartbeat:Connect(function()
		if Tabs:GetAttribute('CurrentTab') == 'Admin' then
			if SearchBar.Text ~= '' then
				local text = SearchBar.Text:lower()
				if args then text = SearchBar.Text:split(' ')[1]:lower() end
				if name:find('^'..text) then
					cmd.Visible = true
				else 
					cmd.Visible = false
					for _, v in next, aliases do
						if v:find('^'..text) then
							cmd.Visible = true
							break
						end
					end
				end 
			elseif ChatBox.Text ~= '' and ChatBox:IsFocused() then
				local text = ChatBox.Text:lower()
				local Pf = string.match(text, '^%s*(.)')
				if Pf == Prefix then
					local Search = text:gsub('%'..Prefix, '')
					if args then Search = Search:split(' ')[1] end
					if name:find('^'..Search) then
						cmd.Visible = true
					else 
						cmd.Visible = false
						for _, v in next, aliases do
							if v:find('^'..Search) then
								cmd.Visible = true
								break
							end
						end
					end 
				else cmd.Visible = true end
			else cmd.Visible = true end
		end
	end))
end

createCmd({'whitelist', {'wl'}, 'If player is whitelisted, it will prevent them from being killed, tased, etc.', {'plr*'}})
createCmd({'blacklist', {'bl'}, 'Removes player from whitelist and removes preventions included when whitelisted', {'plr*'}})
createCmd({'whitelisted', {'getwhitelist', 'getwl'}, 'Logs a list of players in the server that you have whitelisted'})
createCmd({'rank', {'admin'}, 'If player is ranked, they can access a variety of commands exclusive to them', {'plr*'}})
createCmd({'permrank', {'permadmin'}, "If player is permranked, they will always be ranked if they're in your server", {'plr*'}})
createCmd({'unrank', {'unadmin', 'noadmin'}, "Removes the player's rank and access to their commands", {'plr*'}})
createCmd({'ranked', {'admins', 'ranklist', 'adminlist'}, 'Logs a list of players in the server that you have ranked'})
createCmd({'tase', {'taze'}, 'Tases the player, team, or all players', {'plr | team | all*'}})
createCmd({'looptase', {'looptaze'}, 'Tases the player, team, or all players in a loop', {'plr | team | all*'}})
createCmd({'unlooptase', {'unlooptaze'}, 'Stops the player, team, or all players from being tased in a loop', {'plr | team | all*'}})
createCmd({'taserbypass', {'tazerbypass', 'tasebypass', 'tazebypass', 'antitaser', 'antitazer', 'antitase', 'antitaze'}, 'Prevents you from being tased'})
createCmd({'notaserbypass', {'notazerbypass', 'notasebypass', 'notazebypass', 'unantitaser', 'unantitazer', 'unantitase', 'unantitaze'}, 'Allows you to be tased'})
createCmd({'arrest', {}, 'Arrests the player or all criminals', {'plr | all*'}})
createCmd({'clickarrest', {}, 'Clicking a player will arrest them without tools and cooldowns'})
createCmd({'noclickarrest', {'unclickarrest'}, 'Stops clicking from arresting players without tools and cooldowns'})
createCmd({'spamarrest', {'sa'}, 'Arrests the player multiple times until the player becomes an inmate', {'plr*'}})
createCmd({'unspamarrest', {'unsa'}, 'Stops spam arresting the player', {'plr'}})
createCmd({'arrestaura', {'aaura'}, 'Automatically arrests players that are near you'})
createCmd({'noarrestaura', {'unarrestaura', 'noaaura', 'unaaura'}, 'Stops automatically arresting players that are near you'})
createCmd({'kill', {'eliminate', 'elim'}, 'Kills the player, team, or all players', {'plr | team | all*'}})
createCmd({'loopkill', {'lkill', 'lk'}, 'Kills the player, team, or all players in a loop', {'plr | team | all*'}})
createCmd({'safeloopkill', {'safelkill', 'safelk', 'sloopkill', 'slkill', 'slk'}, 'Kills the player, team, or all players in a loop but will not make you switch teams', {'plr*'}})
createCmd({'unloopkill', {'unlkill', 'unlk', 'ulk'}, 'Stops killing the player, team, or all players in a loop', {'plr | team | all*'}})
createCmd({'clickkill', {}, 'Clicking a player will kill them regardless of range'})
createCmd({'noclickkill', {'unclickkill'}, 'Stops clicking from killing players'})
createCmd({'killaura', {'aura'}, 'Automatically kills players that are near you', {'plr', 'range'}})
createCmd({'nokillaura', {'unkillaura', 'noaura', 'unaura'}, 'Stops automatically killing players that are near you', {'plr'}})
createCmd({'inmates', {'inmates', 'prisoner', 'prisoner'}, 'Switches you to the Inmates team'})
createCmd({'guards', {'guard', 'cops', 'cop', 'police'}, 'Switches you to the Guards team'})
createCmd({'criminals', {'criminal', 'crims', 'crim'}, 'Switches you to the Criminals team'})
createCmd({'neutral', {'neutrals'}, 'Switches you to the Neutrals team'})
createCmd({'neutral2', {'custom', 'exploiterneutral', 'fakeneutral'}, 'Switches you to the fake Neutrals team'})
createCmd({'nametag', {'tag', 'colortag', 'color'}, 'Changes your nametag to the color, will not change on chat', {'r*', 'g*', 'b*'}})
createCmd({'makecriminal', {'makecrim', 'criminal', 'crim'}, 'Makes the player, team, or all players switch to the Criminals Team', {'plr | team | all*'}})
createCmd({'lag', {}, 'Makes the server lag indefinitely until you stop it', {'dur', 'sec | min | hr'}})
createCmd({'stoplag', {'unlag'}, 'Stops making the server lag if possible'})
createCmd({'crash', {'crashserver', 'disconnect'}, 'Makes the server lag until the server shuts down'})
createCmd({'stopcrash', {'uncrash', 'uncrashserver'}, 'Stops crashing the server'})
createCmd({'dropfps', {'fpsdrop', 'spikefps', 'spamarmor', 'spamvest'}, "Makes everyone's FPS drop by spamming SWAT armor"})
createCmd({'undropfps', {'unfpsdrop', 'unspikefps', 'unspamarmor', 'unspamvest'}, "Stops making everyone's FPS drop"})
createCmd({'nooverload', {'antioverload', 'no-overload'}, 'Detects duplicates in the workspace then removes them to prevent them from overloading the server'})
createCmd({'allowoverload', {'unantioverload'}, 'Stops detecting duplicates from the workspace and removing them'})
createCmd({'infstamina', {'infinitestamina', 'infjump', 'infinitejump'}, 'Allows you to jump freely without any cooldowns'})
createCmd({'noinfstamina', {'noinfinitestamina', 'noinfjump', 'noinfinitejump'}, 'Stops allowing you to jump freely without any cooldowns'})
createCmd({'earbang', {'earrape'}, 'Creates a loud noise that everyone but you can hear, also lags the chat'})
createCmd({'noearbang', {'noearrape', 'unearbang', 'unearrape'}, 'Will stop creating earrape if it was enabled'})
createCmd({'setspawn', {'spawn'}, 'Sets spawn to your current position, it will also be your spawn point if you are on the fake neutral team'})
createCmd({'resetspawn', {'nospawn'}, 'Resets the spawn point'})
createCmd({'reset', {'oof'}, 'Resets your character'})
createCmd({'respawn', {'res'}, 'Respawns your character to a spawn point'})
createCmd({'refresh', {'ref', 're'}, 'Respawns your character to the same position'})
createCmd({'autorefresh', {'autoref', 'autore'}, 'Automatically respawns your character to the same position if you die'})
createCmd({'unautorefresh', {'unautoref', 'unautore'}, 'Stops automatically respawning your character to the same position if you die'})
createCmd({'god', {'godmode'}, 'Make you immune to death'})
createCmd({'autovest', {}, 'Automatically wears vest to make you heal instantly'})
createCmd({'noautovest', {'unautovest'}, 'Stops automatically wearing vest to make you heal instantly'})
createCmd({'nodaycycle', {'alwaysday'}, 'Removes day cycle and always makes the game day'})
createCmd({'daycycle', {'unalwaysday'}, 'Restores day cycle and stops making the game always day'})
createCmd({'noclip', {}, 'Makes you go through walls'})
createCmd({'clip', {}, 'Stops making you go through walls'})
createCmd({'spectate', {'view'}, 'Spectates the player', {'plr*'}})
createCmd({'unspectate', {'unview'}, 'Stops spectating a player', {'plr'}})
createCmd({'goto', {'to'}, 'Teleports you to the player', {'plr*'}})
createCmd({'bring', {}, 'Brings the player, team, or all players to your position', {'plr | team | all*'}})
createCmd({'loopbring', {}, 'Brings the player, team, or all players to your position in a loop', {'plr | team | all*'}})
createCmd({'unloopbring', {}, 'Will stop bringing the player, team, or all players to your position in a loop', {'plr | team | all'}})
createCmd({'antibring', {'antiattach'}, 'Prevents you from being brought by exploiters'})
createCmd({'unantibring', {'unantiattach'}, 'Stops preventing you from being brought by exploiters'})
createCmd({'fling', {}, 'Flings the player, team, or all players', {'plr | team | all*'}})
createCmd({'unfling', {}, 'Stops flinging the player, team, or all players', {'plr | team | all*'}})
createCmd({'loopfling', {}, 'Flings the player, team, or all players in a loop', {'plr | team | all*'}})
createCmd({'unloopfling', {}, 'Will stop flinging the player, team, or all players in a loop', {'plr | team | all'}})
createCmd({'antifling', {}, 'Prevents you from being flung by exploiters'})
createCmd({'unantifling', {}, 'Stops preventing you from being flung by exploiters'})
createCmd({'fastpunch', {'speedpunch'}, 'Allows you to punch without any cooldowns'})
createCmd({'nofastpunch', {'nospeedpunch', 'unfastpunch', 'unspeedpunch', 'slowpunch'}, 'Stops allowing you to punch without any cooldowns'})
createCmd({'onepunch', {'oneshotpunch', 'one-shotpunch'}, 'Punching instantly kills players'})
createCmd({'noonepunch', {'nooneshotpunch', 'unonepunch', 'unoneshotpunch'}, 'Punching no longer instantly kills players'})
createCmd({'freepunch', {}, 'Allows to punch freely while sprinting or crouching'})
createCmd({'nofreepunch', {'unfreepunch'}, 'Stops allowing you to punch freely while sprinting or crouching'})
createCmd({'superpunch', {'combopunch', 'allpunch'}, 'Activates all punching superpowers'})
createCmd({'nosuperpunch', {'nocombopunch', 'noallpunch', 'normalpunch'}, 'Deactivates all punching superpowers'})
createCmd({'autoshowinv', {'autoshowinventory'}, 'Automatically shows inventory if it was hidden'})
createCmd({'noautoshowinv', {'noautoshowinventory', 'unautoshowinv', 'unautoshowinventory'}, 'Stops automatically showing inventory if it was hidden'})
createCmd({'killtool', {'killgun', 'killweapon', 'killitem'}, 'View or sets the tool that is used for kill commands', {'tool'}})
createCmd({'bringtool', {'teleporttool', 'tptool', 'tpitem'}, 'View or sets the tool that is used for bringing players', {'tool'}})
createCmd({'dropitems', {}, 'Drops items constantly on your position or on a player', {'plr'}})
createCmd({'undropitems', {}, 'Stops dropping items constantly', {'plr'}})
createCmd({'give', {'givetool', 'giveitem', 'attach'}, 'Gives the tool to the player', {'tool*', 'plr*'}})
createCmd({'food', {'foodtray', 'meal'}, 'Gives what food is available to you'})
createCmd({'key', {'keycard', 'card'}, 'Gives a key card to you'})
createCmd({'findkey', {'findkeycard', 'findcard'}, 'Searches for a key card and when available, it is given to you'})
createCmd({'unkey', {'unkeycard', 'uncard'}, 'Stops finding or killing you for a key card'})
createCmd({'knife', {'crudeknife'}, 'Gives a knife to you'})
createCmd({'hammer', {}, 'Gives a hammer to you'})
createCmd({'shield', {'riotshield'}, 'Gives a shield to you'})
createCmd({'antishields', {'antishield'}, 'Removes shields from players, allowing you to shoot the player through them'})
createCmd({'unantishields', {'unantishield'}, 'Restores shields from players, no longer allowing you to shoot the player through them'})
createCmd({'m9', {'pistol'}, 'Gives the M9 to you'})
createCmd({'remington', {'remington870', 'reming', 'shotgun', 'remington=870'}, 'Gives the Remington 870 to you'})
createCmd({'ak-47', {'ak47, ak'}, 'Gives the AK-47 to you'})
createCmd({'m4a1', {'m4'}, 'Gives the AK-47 to you'})
createCmd({'pp', {'penis', 'willy'}, 'Equips all tools and shapes them to create a penis (Funny!)'})
createCmd({'nopp', {'nopenis', 'nowilly'}, 'Unequips all tools and restores their handling positions'})
createCmd({'guns', {'allguns'}, 'Gives you all guns that are available to you'})
createCmd({'autoguns', {'autoallguns'}, "Gives you all guns that are available to you and will keep doing so if you don't have them in your inventory"})
createCmd({'unautoguns', {'unautoallguns'}, "Stops giving you all guns if you don't have them in your inventory"})
createCmd({'refreshgun', {'refgun', 'regun'}, 'Refreshes the tool by removing it from your inventory and then getting it back', {'gun*'}})
createCmd({'refreshguns', {'refguns', 'reguns'}, 'Refreshes all possible items by removing then from your inventory and then getting them back'})
createCmd({'firerate', {'gunspeed', 'firespeed'}, "Sets the gun's fire rate by the number", {'tool*', 'num*'}})
createCmd({'automatic', {'autofire'}, 'Makes M9 or Remington 870 automatic which allows it to be shot while holding click', {'m9 | remington*'}})
createCmd({'modgun', {'gunmods', 'gunmod'}, 'Makes the gun automatic, shoot really fast, have infinite range, and will refresh when the gun is out of ammo', {'gun*'}})
createCmd({'unmodgun', {'ungunmods', 'ungunmod'}, 'Stops making the gun automatic, shoot really fast, have infinite range, and will refresh when the gun is out of ammo', {'gun*'}})
createCmd({'modguns', {'modallguns'}, 'Makes all your guns automatic, shoot really fast, have infinite range, and will refresh when the gun is out of ammo'})
createCmd({'unmodguns', {'unmodallguns'}, 'Stops making all your guns automatic, shoot really fast, have infinite range, and will refresh when the gun is out of ammo'})
createCmd({'gate', {}, 'Teleports you in front of the gate'})
createCmd({'opengate', {}, 'Opens the gate'})
createCmd({'gateroom', {}, 'Teleports you in the gate room'})
createCmd({'gatetower', {}, 'Teleports you on the tower beside the gate'})
createCmd({'tower', {'yardtower'}, 'Teleports you on the tower beside the yard'})
createCmd({'yard', {}, 'Teleports you on the yard'})
createCmd({'prison', {'nexus', 'nex'}, 'Teleports you in the prison'})
createCmd({'backnexus', {'backnex'}, 'Teleports you in the back nexus'})
createCmd({'armory', {'guardroom'}, 'Teleports you in the armory'})
createCmd({'cafeteria', {'cafe', 'lunchroom'}, 'Teleports you in the cafeteria'})
createCmd({'vendingmachine', {'foodmachine', 'machine'}, 'Teleports you in the vending machine'})
createCmd({'sewers', {'sewer'}, 'Teleports you in the sewers'})
createCmd({'roof', {'rooftop', 'prisontop'}, 'Teleports you on the roof of the prison'})
createCmd({'secretroom', {'unusedroom', 'modelsroom', 'library'}, 'Teleports you in an unused room'})
createCmd({'criminalbase', {'crimbase', 'base'}, 'Teleports you in the criminal base'})
createCmd({'baseplate', {'neutralspawn'}, 'Teleports you on the baseplate under the map'})
createCmd({'traproom', {'trap'}, 'Teleports you, the player, team, or all players in a trap room', {'plr | team | all'}})
createCmd({'removevoid', {'antivoid', 'novoid'}, 'Removes fallen parts destroy height to prevent death in the void'})
createCmd({'restorevoid', {'unantivoid', 'void'}, 'Restores fallen parts destroy height and no longer prevents death in the void'})
createCmd({'antiafk', {'antiidle'}, 'Prevents Roblox from kicking you for being idle'})
createCmd({'unantiafk', {'unantiidle'}, 'Stops preventing Roblox from kicking you for being idle'})
createCmd({'rejoin', {'rj'}, 'Makes you rejoin the server'})
createCmd({'serverhop', {'s-hop', 'shop'}, 'Makes you join a different server'})
createCmd({'prefix', {}, 'View or sets the prefix used for commands in chat', {'prefix'}})
createCmd({'autoexecute', {'autoexec'}, 'Automatically execute the command in new servers', {'cmd*'}})
createCmd({'unautoexecute', {'unautoexec'}, 'Stops automatically executing the command in new servers', {'cmd*'}})
createCmd({'autoexecuted', {'autoexecutes', 'autoexecs'}, 'Logs a list of commands that you have enabled auto execution for'})
-->>> Creating command functions
local function execCmd(Command, Args)
	if findInStr({'whitelist', 'wl'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if Whitelist[Player.Name] then Log('[  ]: Already whitelisted '..playerName(Player)) return end
					Whitelist[Player.Name] = true
					HubSettings.Whitelist[Player.Name] = true
					saveSettings()
					Log('[  ]: Whitelisted '..playerName(Player))
				else Log('[  ]: You cannot whitelist yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'blacklist', 'bl'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if not Whitelist[Player.Name] then Log('[  ]: Already blacklisted '..playerName(Player)) return end
					Whitelist[Player.Name] = nil
					HubSettings.Whitelist[Player.Name] = nil
					saveSettings()
					Log('[  ]: Blacklisted '..playerName(Player))
				else Log('[  ]: You cannot blacklist yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'whitelisted', 'getwhitelist', 'getwl'}, Command) then
		local str
		for Player, wl in pairs(Whitelist) do
			if not (Player or wl) then continue end
			local PlayerInGame = findPlayer(Player.Name)
			if PlayerInGame then
				local n = playerName(PlayerInGame)
				if not str then str = ' '..n else str = str..'\n '..n end
			end
		end
		if str then
			Log('[  ]: Whitelist:\n'..str)
		else Log('[  ]: No players in this server are whitelisted') end
	elseif findInStr({'rank', 'admin'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if Ranked[Player.Name] then Log('[  ]: Already ranked '..playerName(Player)) return end
					Ranked[Player.Name] = true
					saveSettings()
					Chat('[  ]: You have been ranked as admin. To view commands, chat '..Prefix..'cmds', Player)
					Log('[  ]: Ranked '..playerName(Player))
				else Log('[  ]: You cannot rank yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'permrank', 'permadmin'}, Command) then
		if not (readfile and writefile and isfile) then 
			Log("[  ]: Your exploit doesn't support this command") 
			return 
		end
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if HubSettings.PermaRanked[Player.Name] then Log('[  ]: Already permanently ranked '..playerName(Player)) return end
					Ranked[Player.Name] = true
					HubSettings.PermaRanked[Player.Name] = true
					saveSettings()
					Chat('[  ]: You have been ranked as admin. To view commands, chat '..Prefix..'cmds', Player)
					Log('[  ]: Permanently ranked '..playerName(Player))
				else Log('[  ]: You cannot permanently rank yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'unrank', 'unadmin'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if not Ranked[Player.Name] then Log('[  ]: Already unranked from '..playerName(Player)) return end
					Ranked[Player.Name] = nil
					if HubSettings.PermaRanked[Player.Name] then HubSettings.PermaRanked[Player.Name] = nil end
					saveSettings()
					Chat('[  ]: You have been unranked and can no longer use commands', Player)
					Log('[  ]: Unranked '..playerName(Player))
				else Log('[  ]: You cannot unrank from yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'ranked', 'admins', 'ranklist', 'adminlist'}, Command) then
		local str
		for Player, wl in pairs(Ranked) do
			if not (Player or wl) then continue end
			local PlayerInGame = findPlayer(Player.Name)
			if PlayerInGame then
				local n = playerName(PlayerInGame)
				if not str then str = ' '..n else str = str..'\n '..n end
			end
		end
		if str then
			Log('[  ]: Rank list:\n'..str)
		else Log('[  ]: No players in this server are ranked') end
	elseif findInStr({'tase', 'taze'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				local allowed
				if not findInInv('Taser') then
					joinTeam('Bright blue', true)
					wait(.25)
					local Team = getTeam()
					if Team ~= 'Bright blue' then Log("[  ]: Couldn't tase all players") 
					else 
						Refresh()
						if findInStr({'Bright orange', 'Medium stone grey'}, Team) then teamEvt(Team) end
						allowed = true 
					end
				else allowed = true end
				if allowed then
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and not Whitelist[Player.Name] and Player.Character then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then Tase(Tased) end
					Log('[  ]: Tased all players')
				end
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						local allowed
						if not findInInv('Taser') then
							joinTeam('Bright blue', true)
							wait(.25)
							local Team = getTeam()
							if Team ~= 'Bright blue' then Log("[  ]: Couldn't tase "..playerName(Player)) 
							else 
								Refresh()
								if findInStr({'Bright orange', 'Medium stone grey'}, Team) then teamEvt(Team) end
								allowed = true 
							end
						else allowed = true end
						if allowed then
							Tase(Player)
							Log('[  ]: Tased '..playerName(Player))
						end
					else Log('[  ]: You cannot tase yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				local allowed
				if not findInInv('Taser') then
					joinTeam('Bright blue', true)
					wait(.25)
					local Team = getTeam()
					if Team ~= 'Bright blue' then Log("[  ]: Couldn't tase "..targetTeam[2]) 
					else 
						Refresh()
						if findInStr({'Bright orange', 'Medium stone grey'}, Team) then teamEvt(Team) end
						allowed = true 
					end
				else allowed = true end
				if allowed then
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit and Player.TeamColor.Name == targetTeam[1] then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then Tase(Tased) end
					Log('[  ]: Tased '..targetTeam[2])
				end
			end
		end
	elseif findInStr({'looptase', 'looptaze'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if Powers.LoopTaseAll then Log('[  ]: Already loop tasing all players') return end
				Powers.LoopTaseAll = true
				Log('[  ]: Loop tasing all players')
				repeat
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then
						if not findInInv('Taser') then
							joinTeam('Bright blue', true)
						end
						Tase(Tased)
					end
					wait(1)
				until not Powers.LoopTaseAll
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if Powers.LoopTased[Player.Name] then Log('[  ]: Already loop tasing '..playerName(Player)) return end
						Powers.LoopTased[Player.Name] = true
						Log('[  ]: Loop tasing '..playerName(Player))
					else Log('[  ]: You cannot loop tase yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				if Powers['LoopTase'..targetTeam[2]] then Log('[  ]: Already loop tasing '..targetTeam[2]) return end
				Powers['LoopTase'..targetTeam[2]] = true
				Log('[  ]: Loop tasing '..targetTeam[2])
				repeat
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.TeamColor.Name == targetTeam[1] then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then
						if not findInInv('Taser') then
							joinTeam('Bright blue', true)
						end
						Tase(Tased)
					end
					wait(1)
				until not Powers['LoopTase'..targetTeam[2]]
			end
		end
	elseif findInStr({'unlooptase', 'unlooptaze'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if not Powers.LoopTaseAll then Log('[  ]: Already stopped loop tasing all players') return end
				Powers.LoopTaseAll = false
				Log('[  ]: Stopped loop tasing all players')
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if not Powers.LoopTased[Player.Name] then Log('[  ]: Already stopped loop tasing '..playerName(Player)) return end
						Powers.LoopTased[Player.Name] = nil
						Log('[  ]: Stopped loop tasing '..playerName(Player))
					else Log('[  ]: You cannot stop loop tasing yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				if not Powers['LoopTase'..targetTeam[2]] then Log('[  ]: Already stopped loop tasing '..targetTeam[2]) return end
				Powers['LoopTase'..targetTeam[2]] = nil
				Log('[  ]: Stopped loop tasing '..targetTeam[2])
			end
		end
	elseif findInStr({'taserbypass', 'tazerbypass', 'tasebypass', 'tazebypass', 'antitaser', 'antitazer', 'antitase', 'antitaze'}, Command) then
		if Powers.TaserBypass then Log('[  ]: Already enabled taser bypass') return end
		Powers.TaserBypass = true
		Log('[  ]: Enabled taser bypass')
		local Tool
		repeat
			pcall(function()
				local char = getChar()
				local hum = char.Humanoid
				local anims = hum:GetPlayingAnimationTracks()
				Tool = char:FindFirstChildOfClass('Tool')
				if Tool then Tool:SetAttribute('lastEquipped', true) end
				for _, v in next, anims do
					local id = v.Animation.AnimationId
					if findInStr({'rbxassetid://279227693', 'rbxassetid://279229192'}, id) then
						spawn(function() 
							StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
							v:Stop() 
						end)
						for _, v in next, User.Backpack:GetChildren() do
							if v:GetAttribute('lastEquipped') then
								v.Parent = char
							end
						end
						if getsenv then getsenv(User.Character.ClientInputHandler).cs.isTazed = false end
						hum.JumpPower = 50
						if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then hum.WalkSpeed = 24
						else hum.WalkSpeed = 16 end
						wait(5)
						if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then hum.WalkSpeed = 24 end
					end
				end
				for _, v in next, User.Backpack:GetChildren() do
					if v:GetAttribute('lastEquipped') then
						v:SetAttribute('lastEquipped', false)
					end
				end
			end)
			Run.Heartbeat:Wait()
		until not Powers.TaserBypass
	elseif findInStr({'notaserbypass', 'notazerbypass', 'notasebypass', 'notazebypass', 'unantitaser', 'unantitazer', 'unantitase', 'unantitaze'}, Command) then
		if not Powers.TaserBypass then Log('[  ]: Already disabled taser bypass') return end
		Powers.TaserBypass = false
		Log('[  ]: Disabled taser bypass')
	elseif Command == 'arrest' then
		if Args[1] then
			if findInStr(Crims, Args[1]) then 
				local Pos = getPos()
				local Arrested = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Head') and not Player.Character.Head:FindFirstChild('handcuffedGui') and Player.TeamColor.Name == 'Really red' then
						local char = getChar()
						if not char or not char:FindFirstChild('Humanoid') or char.Humanoid.Health == 0 then Respawn() end
						Arrest(Player)
						Arrested = Arrested + 1 
					end
				end
				goTo(Pos)
				if Arrested == 0 then Log('[  ]: No Criminals were arrested') return end
				Log('[  ]: Arrested Criminals')
			elseif findInStr(AllPlayers, Args[1]) then
				local Pos = getPos()
				local Arrested = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Head') and not Player.Character.Head:FindFirstChild('handcuffedGui') and findInStr({'Really red', 'Bright orange'}, Player.TeamColor.Name) then
						local char = getChar()
						if not char or not char:FindFirstChild('Humanoid') or char.Humanoid.Health == 0 then Respawn() end
						Arrest(Player)
						if Player.Character.Head:FindFirstChild('handcuffedGui') then Arrested = Arrested + 1 end
					end
				end
				goTo(Pos)
				if Arrested == 0 then Log('[  ]: No players were arrested') return end
				Log('[  ]: Arrested all players')
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if Player.TeamColor.Name == 'Really red' and (Player.Character and Player.Character:FindFirstChild('Head')) then
							if Player.Character.Head:FindFirstChild('handcuffedGui') then Log('[  ] '..playerName(Player)..' is already arrested') return end
							local Pos = getPos()
							local char = getChar()
							if not char or not char:FindFirstChild('Humanoid') or char.Humanoid.Health == 0 then Respawn() end
							Arrest(Player)
							goTo(Pos)
							Log('[  ]: Arrested '..playerName(Player))
						else Log("[  ]: Couldn't arrest "..playerName(Player)) end
					else Log('[  ]: You cannot arrest yourself') end
				else Log('[  ]: No player found') end
			end
		end
	elseif Command == 'clickarrest' then
		if Powers.ClickArrest then Log('[  ]: Already enabled click arresting') return end
		Powers.ClickArrest = true
		Log('[  ]: Enabled click arresting')
		local func; func = Mouse.Button1Down:Connect(function()
			if not Powers.ClickArrest then func:Disconnect() return end
			local char = Mouse.Target:FindFirstAncestorWhichIsA('Model')
			if char then
				local Player = findPlayer(char.Name)
				if Player and Player ~= User and char.Humanoid.Health > 0 then
					arrestEvt:InvokeServer(char.Head)
				end
			end
		end)
	elseif findInStr({'noclickarrest', 'unclickarrest'}, Command) then
		if not Powers.ClickArrest then Log('[  ]: Already disabled click arresting') return end
		Powers.ClickArrest = false
		Log('[  ]: Disabled click arresting')
	elseif findInStr({'spamarrest', 'sa'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if Powers.SpamArresting then
						if Powers.SpamArresting == Player then Log('[  ]: Already spam arresting '..playerName(Player))
						else Log('[  ]: Already spam arresting a different player') end
						return
					end
					local Pos = getPos()
					Powers.SpamArresting = Player
					if Player.TeamColor.Name ~= 'Really red' then MakeCrim(Player) end
					if Player and findPlayer(Player.Name) then
						repeat
							goTo(Player)
							for i = 1, 15 do
								if (not Player or not findPlayer(Player.Name)) or Player.TeamColor.Name ~= 'Really red' then break end
								spawn(function() 
									for i = 1, math.huge do
										if (not Player or not findPlayer(Player.Name)) or Player.TeamColor.Name ~= 'Really red' then break end
										Arrest(Player) 
									end
								end)
								Run.Heartbeat:Wait()
							end
							Run.Heartbeat:Wait()
						until (not Player or not findPlayer(Player.Name)) or Player.TeamColor.Name ~= 'Really red' or Powers.SpamArresting ~= Player
						if Powers.SpamArresting ~= Player then return end
						Log('[  ]: Spam arrested '..playerName(Player))
					else Log("[  ]: Couldn't spam arrest "..playerName(Player)) end
					goTo(Pos)
					Powers.SpamArresting = nil
				else Log('[  ]: You cannot spam arrest yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'unspamarrest', 'unsa'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if Powers.SpamArresting ~= Player then Log('[  ]: Already stopped spam arresting'..playerName(Player)) return end
					Powers.SpamArresting = nil
					Log('[  ]: Stopped spam arresting '..playerName(Player))
				else Log('[  ]: You cannot stop spam arresting yourself') end
			else Log('[  ]: No player found') end
		else 
			if not Powers.SpamArresting then Log('[  ]: Already stopped spam arresting') return end
			Powers.SpamArresting = nil
			Log('[  ]: Stopped spam arresting')
		end
	elseif findInStr({'arrestaura', 'aaura'}, Command) then
		if Powers.ArrestAura then Log('[  ]: Already enabled arrest aura') return end
		Powers.ArrestAura = true
		Log('[  ]: Enabled arrest aura')
		repeat 
			pcall(function()
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Head') and not Player.Head:FindFirstChild('handcuffedGui') and findInStr({'Really red', 'Bright orange'}, Player.TeamColor.Name) then
						local dist = (Player.Character.HumanoidRootPart.Position - User.Character.HumanoidRootPart.Position).Magnitude
						if dist <= 20 then
							arrestEvt:InvokeServer(Player.Character.Head)
						end
					end
				end
			end)
			Run.Heartbeat:Wait()
		until not Powers.ArrestAura
	elseif findInStr({'noarrestaura', 'unarrestaura', 'noaaura', 'unaaura'}, Command) then
		if not Powers.ArrestAura then Log('[  ]: Already disabled arrest aura') return end
		Powers.ArrestAura = false
		Log('[  ]: Disabled arrest aura')
	elseif findInStr({'kill', 'eliminate', 'elim'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				local Killed = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') then
						table.insert(Killed, Player)
					end
				end
				local Team = getTeam()
				if #Killed > 0 then 
					if findInStr({'Bright orange', 'Bright blue', 'Really red'}, Team) then joinTeam('Medium stone grey') end
					Kill(Killed) 
				end
				if getTeam() ~= Team then joinTeam(Team) end
				Log('[  ]: Killed all players')
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if not(Player.Character and Player.Character:FindFirstChild('Humanoid')) or Player.Character.Humanoid.Health == 0 or Player.Character:FindFirstChild('ForceField') then
							Log("[  ]: Couldn't kill "..playerName(Player))
							return
						end
						local Team = getTeam()
						if Player.TeamColor.Name == Team then joinTeam('Medium stone grey') end
						Kill(Player)
						if getTeam() ~= Team then joinTeam(Team) end
						Log('[  ]: Killed '..playerName(Player))
					else Log('[  ]: You cannot kill yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				local Killed = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') and Player.TeamColor.Name == targetTeam[1] then
						table.insert(Killed, Player)
					end
				end
				local Team = getTeam()
				if #Killed > 0 then 
					if targetTeam[1] == Team then joinTeam('Medium stone grey') end
					Kill(Killed) 
				end
				if getTeam() ~= Team then joinTeam(Team) end
				Log('[  ]: Killed '..targetTeam[2])
			end
		end
	elseif findInStr({'loopkill', 'lkill', 'lk'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if Powers.LoopKillAll then Log('[  ]: Already loop killing all players') return end
				Powers.LoopKillAll = true
				Log('[  ]: Loop killing all players')
				repeat
					local Killed = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') then
							table.insert(Killed, Player)
						end
					end
					if #Killed > 0 then
						local Team = getTeam()
						if findInStr({'Bright orange', 'Bright blue', 'Really red'}, Team) then joinTeam('Medium stone grey') end
						Kill(Killed)
					end
					wait(1)
				until not Powers.LoopKillAll
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if Powers.LoopKilled[Player.Name] and not Powers.LoopKilled[Player.Name].Safe then Log('[  ]: Already loop killing '..playerName(Player)) return end
						Powers.LoopKilled[Player.Name] = {Enabled = true, Safe = false}
						Log('[  ]: Loop killing '..playerName(Player))
					else Log('[  ]: You cannot loop kill yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				if Powers['LoopKill'..targetTeam[2]] then Log('[  ]: Already loop killing '..targetTeam[2]) return end
				Powers['LoopKill'..targetTeam[2]] = true
				Log('[  ]: Loop killing '..targetTeam[2])
				repeat
					local Killed = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') and Player.TeamColor.Name == targetTeam[1] then
							table.insert(Killed, Player)
						end
					end
					if #Killed > 0 then
						local Team = getTeam()
						if targetTeam[1] == Team then joinTeam('Medium stone grey') end
						Kill(Killed)
					end
					wait(1)
				until not Powers['LoopKill'..targetTeam[2]]
			end
		end
	elseif findInStr({'safeloopkill', 'safelkill', 'safelk', 'sloopkill', 'slkill', 'slk'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if Powers.LoopKilled[Player.Name] and Powers.LoopKilled[Player.Name].Safe then Log('[  ]: Already safe loop killing '..playerName(Player)) return end
					Powers.LoopKilled[Player.Name] = {Enabled = true, Safe = true}
					Log('[  ]: Safe loop killing '..playerName(Player))
				else Log('[  ]: You cannot loop kill yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'unloopkill', 'unlkill', 'unlk', 'ulk'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if not Powers.LoopKillAll then Log('[  ]: Already stopped loop killing all players') return end
				Powers.LoopKillAll = false
				Log('[  ]: Stopped loop killing all players')
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if not Powers.LoopKilled[Player.Name] then Log('[  ]: Already stopped loop killing '..playerName(Player)) return end
						Powers.LoopKilled[Player.Name] = nil
						Log('[  ]: Stopped loop killing '..playerName(Player))
					else Log('[  ]: You cannot stop loop killing yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				if not Powers['LoopKill'..targetTeam[2]] then Log('[  ]: Already stopped loop killing '..targetTeam[2]) return end
				Powers['LoopKill'..targetTeam[2]] = false
				Log('[  ]: Stopped loop killing '..targetTeam[2])
			end
		end
	elseif Command == 'clickkill' then
		if Powers.ClickKill then Log('[  ]: Already enabled click killing') return end
		Powers.ClickKill = true
		Log('[  ]: Enabled click killing')
		local func; func = Mouse.Button1Down:Connect(function()
			if not Powers.ClickKill then func:Disconnect() return end
			local char = Mouse.Target:FindFirstAncestorWhichIsA('Model')
			if char then
				local Player = findPlayer(char.Name)
				if Player and Player ~= User and char.Humanoid.Health > 0 then
					local dist = (Player.Character.HumanoidRootPart.Position - User.Character.HumanoidRootPart.Position).Magnitude
					if dist <= 20 then
						for i= 1, 15 do
							meleeEvt:FireServer(Player)
						end
					else 
						local Team = getTeam()
						if Player.TeamColor.Name == Team then joinTeam('Medium stone grey') end
						Kill(Player)
						if getTeam() ~= Team then joinTeam(Team) end
					end
				end
			end
		end)
	elseif findInStr({'noclickkill', 'unclickkill'}, Command) then
		if not Powers.ClickKill then Log('[  ]: Already disabled click killing') return end
		Powers.ClickKill = false
		Log('[  ]: Disabled click killing')
	elseif findInStr({'killaura', 'aura'}, Command) then
		local Return
		local Self
		local Player
		local Range
		if Args[1] then
			local num = tonumber(Args[1])
			if num then 
				if num <= 0 or num > 20 then
					Log('[  ]: Type a valid kill aura range from 1-20')
					Return = true
					return
				end
				Range = num 
				Self = true
			else
				Player = findPlayer(Args[1])
				if not Player then 
					Log('[  ]: No player found')
					Return = true
				elseif Player == User then Self = true end
			end
		else Self = true end
		if Return then return end
		if Args[2] then
			if Range then
				Return = true 
				return
			else 
				local num = tonumber(Args[1])
				if num then Range = num else 
					Log('[  ]: Type a valid kill aura range')
					Return = true
				end
			end
		end
		if Return then return end
		if Self then
			if not Powers.KillAura or not Powers.KillAura.Enabled then
				Powers.KillAura = {Enabled = true, Range = Range or 20}
				Log('[  ]: Enabled kill aura')
				if Range then Log('[  ]: Set kill aura range to '..tostring(Range)) end
				repeat
					pcall(function()
						for _, Player in next, Players:GetPlayers() do
							local char = User.Character
							local hrp = char:FindFirstChild('HumanoidRootPart')
							local hum = char:FindFirstChild('Humanoid')
							if Player ~= User and not Whitelist[Player.Name] and (char and not char:FindFirstChild('ForceField')) and hrp and (hum and hum.Health > 0) then
								local dist = (Player.Character.HumanoidRootPart.Position - User.Character.HumanoidRootPart.Position).Magnitude
								if dist <= Powers.KillAura.Range then
									for i= 1, 15 do
										meleeEvt:FireServer(Player)
									end
								end
							end
						end
					end)
					Run.Heartbeat:Wait()
				until not Powers.KillAura or not Powers.KillAura.Enabled
			else
				if Range then
					if Powers.KillAura.Range == Range then Log('[  ]: Already set kill aura range to '..tostring(Ramge)) return end
					if Range <= 0 or Range > 20 then Log('[  ]: Type a valid kill aura range from 1-20') return end
					Powers.KillAura.Range = Range
					Log('[  ]: Set kill aura range to '..tostring(Range))
				else Log('[  ]: Already enabled kill aura') end
			end
		else 
			if not Powers.Aura[Player.Name] or not Powers.Aura[Player.Name].Enabled then
				Powers.Aura[Player.Name] = {Enabled = true, Range = Range or 20}
				Log('[  ]: Enabled kill aura for '..playerName(Player))
				if Range then Log('[  ]: Set kill aura range for '..playerName(Player)..' to '..tostring(Range)) end	
			else 
				if Range then
					if Powers.Aura[Player.Name].Range == Range then Log('[  ]: Already set kill aura range for '..playerName(Player)..' to '..tostring(Range)) return end
					Powers.Aura[Player.Name].Range = Range
					Log('[  ]: Set kill aura range for '..playerName(Player)..' to '..tostring(Range))
				else Log('[  ]: Already enabled kill aura for '..playerName(Player)) end
			end
		end
	elseif findInStr({'nokillaura', 'unkillaura', 'noaura', 'unaura'}, Command) then
		local Self
		local Player
		local Return
		if Args[1] then
			Player = findPlayer(Args[1])
			if not Player then 
				Log('[  ]: No player found')
				Return = true
			elseif Player == User then Self = true end 
		else Self = true end
		if Return then return end
		if Self then
			if not Powers.KillAura or not Powers.KillAura.Enabled then Log('[  ]: Already disabled kill aura') return end
			Powers.KillAura.Enabled = false
			Log('[  ]: Disabled kill aura')
		else
			if not Powers.Aura[Player.Name] or not Powers.Aura[Player.Name].Enabled then Log('[  ]: Already disabled kill aura for '..playerName(Player)) return end
			Powers.Aura[Player.Name].Enabled = false
			Log('[  ]: Disabled kill aura for '..playerName(Player))
		end
	elseif findInStr(Inmates, Command) then
		local Team = getTeam()
		if Team == 'Bright orange' then Log('[  ]: Already joined Inmates team') return end
		joinTeam('Bright orange')
		Log('[  ]: Joined Inmates team')
	elseif findInStr(Guards, Command) then
		local Team = getTeam()
		if Team == 'Bright blue' then Log('[  ]: Already joined Guards team') return end
		local Guards = {}
		for _, Player in next, Players:GetPlayers() do
			if Player.TeamColor.Name == 'Bright blue' then table.insert(Guards, Player) end
		end
		if #Guards >= 8 then Log('[  ]: Cannot join Guards team') return end
		joinTeam('Bright blue')
		Log('[  ]: Joined Guards team')
	elseif findInStr(Crims, Command) and #Args == 0 then
		local Team = getTeam()
		if Team == 'Really red' then Log('[  ]: Already joined Criminals team') return end
		joinTeam('Really red')
		Log('[  ]: Joined Criminals team')
	elseif findInStr({'neutral', 'neutrals'}, Command) then
		local Team = getTeam()
		if Team == 'Really red' then Log('[  ]: Already joined Neutral team') return end
		joinTeam('Medium stone grey')
		Log('[  ]: Joined Neutral team')
	elseif findInStr({'neutral2', 'custom', 'exploiterneutral', 'fakeneutral'}, Command) then
		local Team = getTeam()
		if not findInStr({'Bright orange', 'Bright blue', 'Medium stone grey', 'Really red'}, Team) then 
			Log('[  ]: Already joined secondary Neutral team') 
			return 
		end
		joinTeam(Color3.fromRGB(0, 0, 0))
		Log('[  ]: Joined secondary Neutral team')
	elseif findInStr({'nametag', 'tag', 'colortag', 'color'}, Command) then
		if Args[1] and Args[2] and Args[3] then
			local r, g, b = tonumber(Args[1]), tonumber(Args[2]), tonumber(Args[3])
			if not (r and g and b) then return Log('[  ]: Type a valid RGB color') end
			if (r or g or b) > 255 or (r or g or b) < 0 then return Log('[  ]: Type a valid RGB color') end
			local color = Color3.fromRGB(r, g, b)
			if User.TeamColor.Color == color then 
				Log('[  ]: Already set nametag to '..Args[1]..', '..Args[2]..', '..Args[3])
				return 
			end
			joinTeam(color)
			Log('[  ]: Set nametag to '..Args[1]..', '..Args[2]..', '..Args[3])
		else Log('[  ]: Type a valid RGB color') end
	elseif findInStr({'makecriminal', 'makecrim', 'criminal', 'crim'}, Command) then
		if Args[1] then
			local Team = getTeam()
			local Pos = getPos()
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(AllPlayers, Args[1]) then
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not findInStr({'Medium stone grey', 'Really red'}, Player.TeamColor.Name) then
						if Player.Character.Humanoid.Sit then 
							Kill(Player)
							Player.CharacterAdded:Wait()
						end
						MakeCrim(Player)
						if getTeam() ~= Team then joinTeam(Team) end
						goTo(Pos)
					end
				end
				Log('[  ]: Made all players criminals')
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						MakeCrim(Player)
						if getTeam() ~= Team then joinTeam(Team) end
						goTo(Pos)
						if not Player or not findPlayer(Player.Name) or Player.TeamColor.Name ~= 'Really red' then
							Log("  ]: Couldn't make "..playerName(Player)..' a criminal')
							return
						end
						Log('[  ]: Made '..playerName(Player)..' a criminal')
					else execCmd('criminal', {}) end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.TeamColor.Name == targetTeam[1] then
						if Player.Character.Humanoid.Sit then 
							Kill(Player)
							Player.CharacterAdded:Wait()
						end
						MakeCrim(Player)
						if getTeam() ~= Team then joinTeam(Team) end
						goTo(Pos)
					end
				end
				Log('[  ]: Made '..targetTeam[2]..' criminals')
			end
		end
	elseif Command == 'lag' then
		if Powers.Lag then Log('[  ]: Already lagging the server') return end
		if Args[1] then
			local Return
			local Duration
			local Num = tonumber(Args[1])
			if not Num then
				Log('[  ]: Type a valid duration')
				return
			end
			if Args[2] then
				if findInStr({'s', 'sec', 'secs', 'second', 'seconds'}, Args[2]) then
					Duration = Num
				elseif findInStr({'m', 'min', 'mins', 'minute', 'minutes'}, Args[2]) then
					Duration = Num * 60
				elseif findInStr({'h', 'hr', 'hrs', 'hour', 'hours'}, Args[2]) then
					Duration = Num * 3600
				end
			else Duration = Num end
			if not Duration then return end
			if Duration < 60 then
				local str = 'seconds'
				if Duration == 1 then str = 'second' end
				Log('[  ]: Lagging the server for '..Args[1]..' '..str)
			elseif Duration < 3600 then
				local mins = math.floor(Duration / 60)
				local str = 'minutes'
				if mins == 1 then str = 'minute' end
				Log('[  ]: Lagging the server for '..tostring(mins)..' '..str)
			elseif Duration < 86400 then 
				local hrs = math.floor(Duration / 3600)
				local str = 'hours'
				if hrs == 1 then str = 'hour' end
				Log('[  ]: Lagging the server for '..tostring(hrs)..' '..str)
			end
			Powers.Lag = true
			for i = 1, (Duration * 3) do
				if not Powers.Lag then break end
				getTool('Remington 870')
				local Tool = findInInv('Remington 870')
				local Event = {{['RayObject'] = Ray.new(), ['Distance'] = math.huge, ['Cframe'] = CFrame.new(), ['Hit'] = nil}}
				shootEvt:FireServer(Event, Tool)
			end
			Powers.Lag = false
		else 
			Powers.Lag = true
			Log('[  ]: Lagging the server')
			local Event = {}
			for i = 1, 10 do
				Event[#Event + 1] = {['RayObject'] = Ray.new(), ['Distance'] = math.huge, ['Cframe'] = CFrame.new(), ['Hit'] = nil}
			end
			repeat
				getTool('Remington 870')
				local Tool = findInInv('Remington 870')
				shootEvt:FireServer(Event, Tool)
				Run.Heartbeat:Wait()
			until not Powers.Lag
		end
	elseif findInStr({'stoplag', 'unlag'}, Command) then
		if not Powers.Lag then Log('[  ]: Already stopped lagging the server') return end
		Powers.Lag = false
		Log('[  ]: Stopped lagging the server')
	elseif findInStr({'crash', 'crashserver', 'disconnect'}, Command) then
		if Powers.Crash then Log('[  ]: Already crashing the server') return end
		Powers.Crash = true
		Log('[  ]: Crashing the server')
		local Event = {}
		for i = 1, 5000 do
			if not Powers.Lag then break end
			Event[#Event+1] = {['RayObject'] = Ray.new(), ['Distance'] = 0, ['Cframe'] = CFrame.new(), ['Hit'] = User.Character:FindFirstChildOfClass('Part')}
		end
		repeat
			spawn(function()
				getTool('Remington 870')
				local Tool = findInInv('Remington 870')
				shootEvt:FireServer(Event, Tool)
			end)
			Run.Stepped:Wait()
		until not Powers.Crash
	elseif findInStr({'stopcrash', 'uncrash', 'uncrashserver'}, Command) then
		if not Powers.Crash then Log('[  ]: Already stopped crashing the server') return end
		Powers.Crash = false
		Log('[  ]: Stopped crashing the server')
	elseif findInStr({'dropfps', 'fpsdrop', 'spikefps', 'spamarmor', 'spamvest'}, Command) then
		if not Riot then Log('[  ]: You need to own the Riot Police gamepass to use this command') return end
		if Powers.DropFPS then Log("[  ]: Already dropping server's FPS") return end
		Powers.DropFPS = true
		Log("[  ]: Dropping server's FPS")
		repeat
			local Team = getTeam()
			if Team ~= 'Bright blue' then
				joinTeam('Bright blue', true)
			end
			spawn(function()
				for i = 1, 100 do
					if not Powers.DropFPS then break end
					Equip('Riot Police')
					local char = getChar()
					for _, v in next, char:GetChildren() do
						if v.Name == 'vest' then 
							pcall(function()
								v.Parent = workspace 
								v:Destroy()
							end)
						end
					end
				end
			end)
			Run.Heartbeat:Wait()
		until not Powers.DropFPS
	elseif findInStr({'undropfps', 'unfpsdrop', 'unspikefps', 'unspamarmor', 'unspamvest'}, Command) then
		if not Powers.DropFPS then Log("[  ]: Already stopped dropping server's FPS") return end
		Powers.DropFPS = false
		Refresh()
		Log("[  ]: Stopped dropping server's FPS")
	elseif findInStr({'nooverload', 'no-overload', 'antioverload'}, Command) then
		if Powers.AntiOverload then Log('[  ]: Already enabled anti-overload') return end
		Powers.AntiOverload = true
		Log('[  ]: Enabled anti-overload')
		repeat
			for _, Player in next, Players:GetPlayers() do
				local char = Player.Character
				if char and ((char:FindFirstChild('head') and char.Head:FindFirstChild('handcuffedGui')) or char:FindFirstChild('vest')) then
					local Dupes = {}
					for _, v in next, char:GetDescendants() do
						if not findInStr({'handcuffedGui', 'vest'}, v.Name) then continue end
						local num = Dupes[v.Name] or 0
						Dupes[v.Name] = num + 1
						if Dupes[v.Name] > 1 then 
							v:Destroy()
							if v.Name == 'handcuffedGui' and Player == User then
								spawn(function()
									joinTeam(Color3.fromRGB(0, 0, 0))
								end)
							end
						end
					end
				end
			end
			Run.RenderStepped:Wait()
		until not Powers.AntiOverload
	elseif findInStr({'allowoverload', 'unantioverload'}, Command) then
		if not Powers.AntiOverload then Log('[  ]: Already disabled anti-overload') return end
		Powers.AntiOverload = false
		Log('[  ]: Disabled anti-overload')
	elseif findInStr({'infstamina', 'infinitestamina', 'infjump', 'infinitejump'}, Command) then
		if Powers.InfStamina then Log('[  ]: Already enabled infinite stamina') return end
		if not (getgc and debug and debug.getupvalue and debug.setupvalue) then 
			Log("[  ]: Your exploit doesn't support this command") 
			return 
		end
		Powers.InfStamina = true
		Log('[  ]: Enabled infinite stamina')
		repeat
			local char = getChar()
			local CIH = char:WaitForChild('ClientInputHandler')
			for _, v in next, getgc() do 
				if type(v) == 'function' and getfenv(v).script and getfenv(v).script == CIH then 
					for i,v2 in next, debug.getupvalues(v) do 
						if type(v2) == 'number' and v2 < 999 then 
							debug.setupvalue(v, i, math.huge)
						end
					end
				end
			end
			Run.Heartbeat:Wait()
		until not Powers.InfStamina
	elseif findInStr({'noinfstamina', 'noinfinitestamina', 'noinfjump', 'noinfinitejump'}, Command) then
		if not Powers.InfStamina then Log('[  ]: Already disabled infinite stamina') return end
		Powers.InfStamina = false
		Log('[  ]: Disabled infinite stamina')
		local char = getChar()
		local CIH = char:WaitForChild('ClientInputHandler')
		for _, v in next, getgc() do 
			if type(v) == 'function' and getfenv(v).script and getfenv(v).script == CIH then 
				for i,v2 in next, debug.getupvalues(v) do 
					if type(v2) == 'number' and v2 > 999 then 
						debug.setupvalue(v, i, 12)
					end
				end
			end
		end
	elseif findInStr({'earbang', 'earrape'}, Command) then
		if Powers.Earrape then Log('[  ]: Already earraping the server') return end
		Powers.Earrape = true
		Log('[  ]: Earraping the server')
		repeat
			for _, Player in next, Players:GetPlayers() do
				if not Powers.Earrape then break end
				if Player.Character and Player.Character:FindFirstChildOfClass('Part') then
					local source = Player.Character:FindFirstChildOfClass('Part')
					local sound = workspace['Prison_guardspawn'].spawn.Sound
					spawn(function()
						for i = 1, 3 do
							soundEvt:FireServer(sound, source)
						end
					end)
				end
			end
			Run.Heartbeat:Wait()
		until not Powers.Earrape
	elseif findInStr({'noearbang', 'noearrape', 'unearbang', 'unearrape'}, Command) then
		if not Powers.Earrape then Log('[  ]: Already stopped earraping the server') return end
		Powers.Earrape = false
		Log('[  ]: Stopped earraping the server')
	elseif findInStr({'setspawn', 'spawn'}, Command) then
		local Pos = getPos()
		local x = math.floor(Pos.p.X + .5)
		local y = math.floor(Pos.p.Y + .5)
		local z = math.floor(Pos.p.Z + .5)
		if not Powers.SpawnPoint then
			Powers.SpawnPoint = Pos
			Log('[  ]: Set spawn point to '..x..', '..y..', '..z)
			local func; func = User.CharacterAdded:Connect(function(char)
				if not Powers.SpawnPoint then func:Disconnect() return end
				if Re then Re = false return end
				repeat wait() until char:FindFirstChild('HumanoidRootPart')
				goTo(Powers.SpawnPoint)
			end)
		else 
			if Pos ~= Powers.SpawnPoint then
				Powers.SpawnPoint = Pos
				Log('[  ]: Set spawn point to '..x..', '..y..', '..z)
			else Log('[  ]: Already set spawn point to '..x..', '..y..', '..z) end
		end
	elseif findInStr({'resetspawn', 'nospawn'}, Command) then
		if not Powers.SpawnPoint then Log('[  ]: Already reset spawn point') return end
		Powers.SpawnPoint = false
		Log('[  ]: Reset spawn point')
	elseif findInStr({'reset', 'oof'}, Command) then
		local char = getChar()
		if not char or not char:FindFirstChildOfClass('Humanoid') or char.Humanoid.Health <= 0 then
			Log('[  ]: Cannot reset character')
			return
		end
		char.Humanoid.Health = 0
		Log('[  ]: Reset character')
	elseif findInStr({'respawn', 'res'}, Command) then
		Respawn()
		Log('[  ]: Respawned character')
	elseif findInStr({'refresh', 'ref', 're'}, Command) then
		Refresh()
		Log('[  ]: Refreshed character')
	elseif findInStr({'autorefresh', 'autoref', 'autore'}, Command) then
		if Powers.AutoRefresh then Log('[  ]: Already enabled auto refreshing') return end
		Powers.AutoRefresh = true
		Log('[  ]: Enabled auto refreshing')
		repeat
			local char = getChar()
			if not char or not char:FindFirstChildOfClass('Humanoid') or char.Humanoid.Health <= 0 then
				Refresh()
			end
			Run.Heartbeat:Wait()
		until not Powers.AutoRefresh
	elseif findInStr({'unautorefresh', 'unautoref', 'unautore'}, Command) then
		if not Powers.AutoRefresh then Log('[  ]: Already disabled auto refreshing') return end
		Powers.AutoRefresh = false
		Log('[  ]: Disabled auto refreshing')
	elseif findInStr({'god', 'godmode'}, Command) then
		if Powers.God then Log('[  ]: Already enabled god modes') return end
		Powers.God = true
		God()
		Log('[  ]: Enabled god mode')
	elseif Command == 'autovest' then
		if not Riot then Log('[  ]: You need to own the Riot Police gamepass to use this command') return end
		if Powers.AutoVest then Log('[  ]: Already enabled auto wearing vest') return end
		Powers.AutoVest = true
		Log('[  ]: Enabled auto wearing vest')
		repeat
			local char = getChar()
			if char and char:FindFirstChild('Humanoid') and char.Humanoid.Health < char.Humanoid.MaxHealth then
				Equip('Riot Police')
				char:FindFirstChild('vest'):Destroy()
			end
			Run.Heartbeat:Wait()
		until not Powers.AutoVest
	elseif findInStr({'noautovest', 'unautovest'}, Command) then
		if not Powers.AutoVest then Log('[  ]: Already disabled auto wearing vest') return end
		Powers.AutoVest = false
		Log('[  ]: Disabled auto wearing vest')
	elseif findInStr({'nodaycycle', 'alwaysday'}, Command) then
		if Powers.AlwaysDay then Log('[  ]: Already disabled day cycle') return end
		Powers.AlwaysDay = true
		Log('[  ]: Disabled day cycle')
		repeat
			Lighting.Brightness = 1.5
			Lighting.ClockTime = 12
			Lighting.ShadowSoftness = .5
			Lighting.OutdoorAmbient = Color3.fromRGB(222, 222, 222)
			Run.RenderStepped:Wait()
		until not Powers.AlwaysDay
	elseif findInStr({'daycycle', 'unalwaysday'}, Command) then
		if not Powers.AlwaysDay then Log('[  ]: Already enabled day cycle') return end
		Powers.AlwaysDay = false
		Log('[  ]: Enabled day cycle')
	elseif Command == 'noclip' then
		if Powers.Noclip then Log('[  ]: Already enabled noclipping') return end
		Powers.Noclip = true
		Log('[  ]: Enabled noclipping')
		repeat
			local char = getChar()
			if char then
				for _, v in next, char:GetChildren() do
					if findInStr({'Head', 'Torso', 'Left Arm', 'Right Arm', 'Left Leg', 'Right Leg'}, v.Name) and v.CanCollide == true then
						v.CanCollide = false
					end
				end
			end
			Run.Stepped:Wait()
		until not Powers.Noclip
	elseif Command == 'clip' then
		if not Powers.Noclip then Log('[  ]: Already disabled noclipping') return end
		Powers.Noclip = false
		local char = getChar()
		if char then
			for _, v in next, char:GetChildren() do
				if findInStr({'Head', 'Torso', 'Left Arm', 'Right Arm', 'Left Leg', 'Right Leg'}, v.Name) and v.CanCollide == false then
					v.CanCollide = true
				end
			end
		end
		Log('[  ]: Disabled noclipping')
	elseif findInStr({'view', 'spectate'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if not Powers.Spectating then
						Powers.Spectating = Player
						Log('[  ]: Spectating '..playerName(Player))
						repeat
							pcall(function()
								local char = Powers.Spectating.Character
								if char and char:FindFirstChild('Humanoid') and Cam.CameraSubject ~= char.Humanoid then
									Cam.CameraSubject = char.Humanoid
								end
							end)
							Run.RenderStepped:Wait()
						until not Powers.Spectating
					else
						if Powers.Spectating ~= Player then
							Powers.Spectating = Player
							Log('[  ]: Spectating '..playerName(Player))
						else Log('[  ]: Already spectating '..playerName(Player)) end
					end
				else Log('[  ]: You cannot spectate yourself') end
			else Log('[  ]: No player found') end
		end
	elseif findInStr({'unview', 'unspectate'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					if Powers.Spectating ~= Player then Log('[  ]: You are not spectating '..playerName(Player)) return end
					Powers.Spectating = nil
					local char = getChar()
					Cam.CameraSubject = char
					Log('[  ]: Stopped spectating '..playerName(Player))
				else Log('[  ]: You cannot spectate yourself') end
			else Log('[  ]: No player found') end
		else 
			if not Powers.Spectating then Log('[  ]: You are not spectating anyone') return end
			Powers.Spectating = nil
			local char = getChar()
			Cam.CameraSubject = char
			Log('[  ]: Stopped spectating')
		end
	elseif findInStr({'goto', 'to'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					local char = getChar()
					if not char then Log("[  ]: Couldn't teleport to "..playerName(Player)) return end
					local Pos = char:GetPivot()
					goTo(Player)
					if char:GetPivot() == Pos then Log("[  ]: Couldn't teleport to "..playerName(Player)) return end
					Log('[  ]: Teleported to '..playerName(Player))
				else Log('[  ]: You cannot teleport to yourself') end
			else Log('[  ]: No player found') end
		end
	elseif Command == 'bring' then
		if Args[1] then
			if Powers.Bring or Powers.LoopBring then Log('[  ]: You cannot bring other players right now') return end
			local Pos = getPos()
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				Powers.Bring = true
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit and not Player.Character.Torso.Anchored then
						Bring(Player, Pos)
					end
				end
				Powers.Bring = false
				Log('[  ]: Brought all players')
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						Powers.Bring = true
						Bring(Player, Pos)
						Powers.Bring = false
						if findPlayer(Player.Name) then Log('[  ]: Brought '..playerName(Player))
						else Log("[  ]: Couldn't bring "..playerName(Player)) end
					else Log('[  ]: You cannot bring yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				Powers.Bring = true
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and not Whitelist[Player.Name] and (Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit) and Player.TeamColor.Name == targetTeam[1] then
						Bring(Player, Pos)
					end
				end
				Powers.Bring = false
				Log('[  ]: Brought '..targetTeam[2])
			end
		end
	elseif Command == 'loopbring' then
		if Args[1] then
			if Powers.Bring then Log('[  ]: You cannot loop bring any players right now') return end
			local Bringing = {}
			local Return
			if findInStr(Inmates, Args[1]) then
				Bringing = {Type = 'Team', Target = 'Bright orange', Name = 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				Bringing = {Type = 'Team', Target = 'Bright blue', Name = 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				Bringing = {Type = 'Team', Target = 'Really red', Name = 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				Bringing = {Type = 'All', Target = nil, Name = 'all players'}
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						Bringing = {Type = 'plr', Target = Player, Name = playerName(Player)}
					else 
						Log('[  ]: You cannot loop bring yourself') 
						Return = true
					end
				else 
					Log('[  ]: No player found') 
					Return = true
				end
			end
			if Return then return end
			Bringing.Position = getPos()
			if not Powers.LoopBring then
				Powers.LoopBring = Bringing
				Log('[  ]: Loop bringing '..Bringing.Name)
				local Pos = Powers.LoopBring.Position
				repeat
					local b = Powers.LoopBring
					if b.Type == 'Team' then
						for _, Player in next, Players:GetPlayers() do
							if not Powers.LoopBring or Powers.LoopBring.Type ~= 'Team' then break end
							if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit and Player.TeamColor.Name == b.Target then
								Bring(Player, Pos)
							end
						end
					elseif b.Type == 'plr' then
						local Player = findPlayer(b.Target.Name)
						if Player and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit then
							Bring(Player, Pos)
						end
					else
						for _, Player in next, Players:GetPlayers() do
							if not Powers.LoopBring or Powers.LoopBring.Type ~= 'All' then break end
							if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit and not Player.Character.Torso.Anchored then
								Bring(Player, Pos)
							end
						end
					end
					Run.Heartbeat:Wait()
				until not Powers.LoopBring
			else 
				if Powers.LoopBring ~= Bringing then
					Powers.LoopBring = Bringing
					Log('[  ]: Loop bringing '..Bringing.Name)
				else Log('[  ]: Already loop bringing '..Bringing.Name) end
			end
		end
	elseif Command == 'unloopbring' then
		if Args[1] then
			local Bringing = {}
			local Return
			if findInStr(Inmates, Args[1]) then
				Bringing = {Type = 'Team', Target = 'Bright orange', Name = 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				Bringing = {Type = 'Team', Target = 'Bright blue', Name = 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				Bringing = {Type = 'Team', Target = 'Really red', Name = 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				Bringing = {Type = 'All', Target = nil, Name = 'all players'}
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						Bringing = {Type = 'plr', Target = Player, Name = playerName(Player)}
					else 
						Log('[  ]: You cannot stop loop bringing yourself') 
						Return = true
					end
				else 
					Log('[  ]: No player found') 
					Return = true
				end
			end
			if Return then return end
			if not Powers.LoopBring or Powers.LoopBring ~= Bringing then Log('[  ]: You are not loop bringing '..Bringing.Name) return end
			Powers.LoopBring = nil
			Log('[  ]: Stopped loop bringing '..Bringing.Name)
		else 
			if not Powers.LoopBring then Log('[  ]: You are not loop bringing anyone') return end
			Powers.LoopBring = nil
			Log('[  ]: Stopped loop bringing')
		end
	elseif findInStr({'antibring', 'antiattach'}, Command) then
		if Powers.AntiBring then Log('[  ]: Already enabled anti-bring') return end
		Powers.AntiBring = true
		Log('[  ]: Enabled anti-bring')
		repeat
			local char = getChar()
			if char then
				local Pos = getPos()
				local arm = char:FindFirstChild('Right Arm')
				local hum = char:FindFirstChild('Humanoid')
				if arm and hum and arm:FindFirstChild('RightGrip') and arm.RightGrip:IsA('Weld') then
					local part = arm.RightGrip.Part1
					local Tool = part:FindFirstAncestorWhichIsA('Tool')
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and Player.Character and Player.Character:FindFirstChild('Right Arm') then
							local grip = Player.Character['Right Arm']:FindFirstChild('RightGrip')
							if grip and grip:IsA('Weld') and grip.Part1 == part then
								hum:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
								hum:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
								arm.Parent = nil
								Tool.Parent = User.Backpack
								Tool.Handle:Destroy()
								Tool.Parent = char
								Tool:Destroy()
								arm.Parent = char
								break
							end
						end
					end
				end
			end
			Run.RenderStepped:Wait()
		until not Powers.AntiBring
	elseif findInStr({'unantibring', 'unantiattach'}, Command) then
		if not Powers.AntiBring then Log('[  ]: Already disabled anti-bring') return end
		Powers.AntiBring = false
		Log('[  ]: Disabled anti-bring')
	elseif Command == 'fling' then
		if Powers.Fling or Powers.LoopFling then Log('[  ]: You cannot fling other players right now') return end
		local Pos = getPos()
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				Powers.Fling = true
				for _, Player in next, Players:GetPlayers() do
					if not Powers.Fling then break end
					if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit then
						Fling(Player)
					end
				end
				Respawn()
				goTo(Pos)
				Powers.Fling = false
				Log('[  ]: Flung all players')
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						Powers.Fling = true
						Fling(Player)
						Respawn()
						goTo(Pos)
						Powers.Fling = false
						Log('[  ]: Flung '..playerName(Player))
					else Log('[  ]: You cannot fling yourself') end
				else Log('[  ]: No player found') end
			end
			if targetTeam then
				Powers.Fling = true
				for _, Player in next, Players:GetPlayers() do
					if not Powers.Fling then break end
					if Player ~= User and not Whitelist[Player.Name] and (Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit) and Player.TeamColor.Name == targetTeam[1] then
						Fling(Player)
					end
				end
				Respawn()
				goTo(Pos)
				Powers.Fling = false
				Log('[  ]: Flung '..targetTeam[2])
			end
		end
	elseif Command == 'unfling' then
		if not Powers.Fling then Log('[  ]: Already stopped flinging') return end
		Powers.Fling = false
		Log('[  ]: Stopped flinging')
	elseif Command == 'loopfling' then
		if Args[1] then
			if Powers.Fling then Log('[  ]: You cannot loop fling any players right now') return end
			local Flinging = {}
			local Return
			if findInStr(Inmates, Args[1]) then
				Flinging = {Type = 'Team', Target = 'Bright orange', Name = 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				Flinging = {Type = 'Team', Target = 'Bright blue', Name = 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				Flinging = {Type = 'Team', Target = 'Really red', Name = 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				Flinging = {Type = 'All', Target = nil, Name = 'all players'}
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						Flinging = {Type = 'plr', Target = Player, Name = playerName(Player)}
					else 
						Log('[  ]: You cannot loop fling yourself') 
						Return = true
					end
				else 
					Log('[  ]: No player found') 
					Return = true
				end
			end
			if Return then return end
			if not Powers.LoopFling then
				Powers.LoopFling = Flinging
				Log('[  ]: Loop flinging '..Flinging.Name)
				repeat
					pcall(function()
						local f = Powers.LoopFling
						if f.Type == 'Team' then
							for _, Player in next, Players:GetPlayers() do
								if not Powers.LoopFling or Powers.LoopFling.Type ~= 'Team' then break end
								if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit and Player.TeamColor.Name == f.Target then
									Fling(Player)
								end
							end
						elseif f.Type == 'plr' then
							local Player = findPlayer(f.Target.Name)
							if Player and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit then
								Fling(Player)
							end
						else
							for _, Player in next, Players:GetPlayers() do
								if not Powers.LoopFling or Powers.LoopFling.Type ~= 'All' then break end
								if Player ~= User and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit then
									Fling(Player)
								end
							end
						end
					end)
					Run.Heartbeat:Wait()
				until not Powers.LoopFling
			else 
				if Powers.LoopFling ~= Flinging then
					Powers.LoopFling = Flinging
					Log('[  ]: Loop flinging '..Flinging.Name)
				else Log('[  ]: Already loop flinging '..Flinging.Name) end
			end
		end
	elseif Command == 'unloopfling' then
		if Args[1] then
			local Flinging = {}
			local Return
			if findInStr(Inmates, Args[1]) then
				Flinging = {Type = 'Team', Target = 'Bright orange', Name = 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				Flinging = {Type = 'Team', Target = 'Bright blue', Name = 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				Flinging = {Type = 'Team', Target = 'Really red', Name = 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				Flinging = {Type = 'All', Target = nil, Name = 'all players'}
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						Flinging = {Type = 'plr', Target = Player, Name = playerName(Player)}
					else 
						Log('[  ]: You cannot stop loop flinging yourself') 
						Return = true
					end
				else 
					Log('[  ]: No player found') 
					Return = true
				end
			end
			if Return then return end
			if not Powers.LoopFling or Powers.LoopFling ~= Flinging then Log('[  ]: You are not loop flinging '..Flinging.Name) return end
			Powers.LoopFling = nil
			Log('[  ]: Stopped loop flinging '..Flinging.Name)
		else 
			if not Powers.LoopFling then Log('[  ]: You are not loop flinging anyone') return end
			Powers.LoopFling = nil
			Log('[  ]: Stopped loop flinging')
		end
	elseif Command == 'antifling' then
		if Powers.AntiFling then Log('[  ]: Already enabled anti-fling') return end
		Powers.AntiFling = true
		Log('[  ]: Enabled anti-fling')
		repeat
			local char = getChar()
			if char and char:FindFirstChild('Torso') then
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and Player.Character then
						for _, v in next, Player.Character:GetChildren() do
							if v:IsA('BasePart') and v.RotVelocity.Magnitude >= 999 then
								char.Torso.Anchored = true
								v.CanCollide = false
								v.CanTouch = false
								v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
								v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
								v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
								v.Massless = true
								char.Torso.Anchored = false
								Run.RenderStepped:Wait()
							end
						end
					end
				end
			end
			Run.Heartbeat:Wait()
		until not Powers.AntiFling
	elseif Command == 'unantifling' then
		if not Powers.AntiFling then Log('[  ]: Already disabled anti-fling') return end
		Powers.AntiFling = false
		Log('[  ]: Disabled anti-fling')
	elseif findInStr({'fastpunch', 'speedpunch'}, Command) then
		if not getsenv then Log("[  ]: Your exploit doesn't support this command") return end
		if Powers.FastPunch or Powers.SuperPunch then Log('[  ]: Already enabled fast punching') return end
		Powers.FastPunch = true
		Log('[  ]: Enabled fast punching')
	elseif findInStr({'nofastpunch', 'nospeedpunch', 'unfastpunch', 'unspeedpunch', 'slowpunch'}, Command) then
		if Powers.SuperPunch then Log('[  ]: Cannot disable fast punching') return end
		if not Powers.FastPunch then Log('[  ]: Already disabled fast punching') return end
		Powers.FastPunch = false
		Log('[  ]: Disabled fast punching')
	elseif findInStr({'onepunch', 'oneshotpunch', 'one-shotpunch'}, Command) then
		if not getsenv then Log("[  ]: Your exploit doesn't support this command") return end
		if Powers.OnePunch or Powers.SuperPunch then Log('[  ]: Already enabled one punching') return end
		Powers.OnePunch = true
		Log('[  ]: Enabled one punching')
	elseif findInStr({'noonepunch', 'nooneshotpunch', 'unonepunch', 'unoneshotpunch'}, Command) then
		if Powers.SuperPunch then Log('[  ]: Cannot disable one punching') return end
		if not Powers.OnePunch or Powers.SuperPunch then Log('[  ]: Already disabled one punching') return end
		Powers.OnePunch = false
		Log('[  ]: Disabled one punching')
	elseif Command == 'freepunch' then
		if not getsenv then Log("[  ]: Your exploit doesn't support this command") return end
		if Powers.FreePunch or Powers.SuperPunch then Log('[  ]: Already enabled free punching') return end
		Powers.FreePunch = true
		Log('[  ]: Enabled free punching')
		local func; func = Mouse.KeyDown:Connect(function(k)
			if not Powers.FreePunch then func:Disconnect() return end
			local char = getChar()
			if k == 'f' and char then
				local CIH = char:FindFirstChild('ClientInputHandler')
				if CIH then
					local handler = getsenv(CIH).cs
					if handler.isRunning then
						handler.isRunning = false
						wait(.1)
						handler.isRunning = true
					end
					if handler.isCrouching then
						handler.isCrouching = false
						wait(.1)
						handler.isCrouching = true
					end
					if handler.isTazed then
						handler.isTazed = false
						wait(.1)
						handler.isTazed = true
					end
					if handler.isArrested then
						handler.isArrested = false
						wait(.1)
						handler.isArrested = true
					end
				end
			end
		end)
	elseif findInStr({'nofreepunch', 'unfreepunch'}, Command) then
		if Powers.SuperPunch then Log('[  ]: Cannot disable free punching') return end
		if not Powers.FreePunch then Log('[  ]: Already disabled free punching') return end
		Powers.FreePunch = false
		Log('[  ]: Disabled free punching')
	elseif findInStr({'superpunch', 'allpunch', 'combopunch'}, Command) then
		if not getsenv then Log("[  ]: Your exploit doesn't support this command") return end
		if Powers.SuperPunch then Log('[  ]: Already enabled super punching') return end
		Powers.FastPunch = false
		Powers.OnePunch = false
		Powers.FreePunch = false
		Powers.SuperPunch = true
		Log('[  ]: Enabled super punching')
		local func; func = Mouse.KeyDown:Connect(function(k)
			if not Powers.SuperPunch then func:Disconnect() return end
			local char = getChar()
			if k == 'f' and char then
				local CIH = char:FindFirstChild('ClientInputHandler')
				if CIH then
					local handler = getsenv(CIH).cs
					if handler.isRunning then
						handler.isRunning = false
						wait(.1)
						handler.isRunning = true
					end
					if handler.isCrouching then
						handler.isCrouching = false
						wait(.1)
						handler.isCrouching = true
					end
					if handler.isTazed then
						handler.isTazed = false
						wait(.1)
						handler.isTazed = true
					end
					if handler.isArrested then
						handler.isArrested = false
						wait(.1)
						handler.isArrested = true
					end
				end
			end
		end)
	elseif findInStr({'nosuperpunch', 'noallpunch', 'nocombopunch', 'normalpunch'}, Command) then
		if not Powers.SuperPunch then Log('[  ]: Already disabled super punching') return end
		Powers.SuperPunch = false
		Log('[  ]: Disabled super punching')
	elseif findInStr({'autoshowinv', 'autoshowinventory'}, Command) then
		if not getsenv then Log("[  ]: Your exploit doesn't support this command") return end
		if Powers.AutoShowInv then Log('[  ]: Already enabled auto showing inventory') return end
		Powers.AutoShowInv = true
		Log('[  ]: Enabled auto showing inventory')
		repeat
			local char = getChar()
			local CIH = char:FindFirstChild('ClientInputHandler')
			if char and CIH then
				local handler = getsenv(CIH).cs
				if handler.isCrouching or handler.isTazed or handler.isArrested then 
					StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
				end
			end
			Run.RenderStepped:Wait()
		until not Powers.AutoShowInv
	elseif findInStr({'noautoshowinv', 'noautoshowinventory','unautoshowinv', 'unautoshowinventory'}, Command) then
		if not Powers.AutoShowInv then Log('[  ]: Already disabled auto showing inventory') return end
		Powers.AutoShowInv = false
		Log('[  ]: Disabled auto showing inventory')
	elseif findInStr({'killtool', 'killgun', 'killweapon', 'killitem'}, Command) then
		if Args[1] then
			local Tool
			local Return
			if findInStr(M9, Args[1]) then
				Tool = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Tool = 'Remington 870'
			elseif findInStr(AK47, Args[1]) then
				Tool = 'AK-47'
			elseif findInStr(M4A1, Args[1]) then
				Tool = 'M4A1'
			else 
				Log("[  ]: Couldn't find the item to set the kill Tool for")
			end
			if not Tool then return end
			if KillTool == Tool then Log('[  ]: Already set kill Tool to '..Tool) return end
			KillTool = Tool
			saveSettings()
			Log('[  ]: Set kill Tool to '..Tool)
		else Log('[  ]: The kill Tool is set to '..KillTool) end
	elseif findInStr({'bringtool', 'teleporttool', 'tptool', 'tpitem'}, Command) then
		if Args[1] then
			local Tool
			local Return
			if findInStr(M9, Args[1]) then
				Tool = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Tool = 'Remington 870'
			elseif findInStr(AK47, Args[1]) then
				Tool = 'AK-47'
			elseif findInStr(M4A1, Args[1]) then
				Tool = 'M4A1'
			elseif Args[1] == 'Hammer' then
				Tool = 'Hammer'
			elseif findInStr({'crudeknife', 'knife'}, Args[1]) then
				Tool = 'Crude Knife'
			else 
				Log("[  ]: Couldn't find the item to set the bring Tool for")
			end
			if not Tool then return end
			if TPTool == Tool then Log('[  ]: Already set bring Tool to '..Tool) return end
			TPTool = Tool
			saveSettings()
			Log('[  ]: Set bring Tool to '..Tool)
		else Log('[  ]: The bring Tool is set to '..TPTool) end
	elseif Command == 'dropitems' then
		local Return
		if not Powers.DropItems or not Powers.DropItems.Enabled then
			if Args[1] then
				local Player = findPlayer(Args[1])
				if Player then
					if Player == User then Powers.DropItems = {Enabled = true, Target = nil} return end
					Powers.DropItems = {Enabled = true, Target = Player}
				else 
					Log('[  ]: No player found') 
					Return = true
				end
			else Powers.DropItems = {Enabled = true, Target = nil} end
			if Return then return end
			if Powers.DropItems.Target then Log('[  ]: Dropping items to'..playerName(Powers.DropItems.Target))
			else Log('[  ]: Enabled dropping items') end
			local Pos = getPos()
			repeat
				local Team = getTeam()
				if Team ~= 'Bright blue' then
					joinTeam('Bright blue', true)
				end
				local char = getChar()
				if char and char:FindFirstChild('Humanoid') then
					if char.Humanoid.Health == 0 then
						Respawn()
						if Powers.DropItems.Target then
							local Player = Powers.DropItems.Target
							if findPlayer(Player.Name) then
								goTo(Player)
							end
						else 
							goTo(Pos)
						end
					else wait(.1555555) char.Humanoid.Health = 0 end
				end
				Run.RenderStepped:Wait()
			until not Powers.DropItems or not Powers.DropItems.Enabled
		else 
			if Args[1] then
				local Player = findPlayer(Args[1])
				if Player then
					if Powers.DropItems.Target == Player then Log('[  ]: Already dropping items to'..playerName(Player)) return end
					Powers.DropItems.Target = Player
					Log('[  ]: Dropping items to'..playerName(Player))
				else Log('[  ]: No player found') end
			else Log('[  ]: Already enabled dropping items') end
		end
	elseif Command == 'undropitems' then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Powers.DropItems.Target ~= Player then 
					if not Powers.DropItems.Target then Log('[  ]: Already stopped dropping items to'..playerName(Player))
					else Log('[  ]: You are not dropping items to'..playerName(Player)) end
					return 
				end
				Powers.DropItems.Enabled = false
				Powers.DropItems.Target = nil
				Log('[  ]: Stopped dropping items to'..playerName(Player))
			else Log('[  ]: No player found')  end
		else 
			if not Powers.DropItems or not Powers.DropItems.Enabled then Log('[  ]: Already disabled dropping items') return end
			Powers.DropItems.Enabled = false
			if Powers.DropItems.Target then 
				Powers.DropItems.Target = nil
				Log('[  ]: Stopped dropping items')
			else Log('[  ]: Disabled dropping items') end
		end
	elseif findInStr({'give', 'givetool', 'giveitem', 'attach'}, Command) then
		local Team = getTeam()
		local Player
		local Tool
		local Return
		if Args[1] then
			Player = findPlayer(Args[1])
			if not Player then 
				Log('[  ]: No player found') 
				Return = true
			elseif Player == User then 
				Log('[  ]: You cannot give items to yourself') 
				Return = true
			end
		else Return = true end
		if Return then return end
		if Args[2] then
			local Name
			if findInStr(M9, Args[2]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[2]) then
				Name = 'Remington 870'
			elseif findInStr(AK47, Args[2]) then
				Name = 'AK-47'
			elseif findInStr(M4A1, Args[2]) then
				if not Riot then
					Log('[  ]: You need to own the Riot Police gamepass to give the M4A1')
					Return = true
				end
				Name = 'M4A1'
			elseif findInStr({'taser', 'tazer'}, Args[2]) then
				Name = 'Taser'
			elseif Args[2] == 'hammer' then
				Name = 'Hammer'
			elseif findInStr({'crudeknife', 'knife'}, Args[2]) then
				Name = 'Crude Knife'
			elseif findInStr({'handcuffs', 'cuffs'}, Args[2]) then
				Name = 'Handcuffs'
			elseif findInStr({'shield', 'riotshield'}, Args[2]) then
				if not Riot then
					Log('[  ]: You need to own the Riot Police gamepass to give the shield')
					Return = true
				end
				Name = 'Riot Shield'
			elseif findInStr({'key', 'keycard', 'card'}, Args[2]) then
				Name = 'Key card'
			elseif Args[2] == 'breakfast' then
				Name = 'Breakfast'
			elseif Args[2] == 'lunch' then
				Name = 'Lunch'
			elseif Args[2] == 'dinner' then
				Name = 'Dinner'
			else 
				Log("[  ]: Couldn't find the item to give")
				Return = true
			end
			if Return then return end 
			if not findInInv(Name) then
				if findInStr({'Taser', 'Handcuffs'}, Name) then
					joinTeam('Bright blue', true)
				else
					if findInStr({'Breakfast', 'Lunch', 'Dinner'}, Name) and not giver:FindFirstChild(Name) then 
						Log('[  ]: Cannot give '..Name..' to '..playerName(Player)) 
						Return = true
					end
					if Return then return end
					getTool(Name)
				end
			end
			Tool = findInInv(Name)
		else Tool = User.Character:FindFirstChildOfClass('Tool') or User.Backpack:FindFirstChildOfClass('Tool') end
		if Return then return end
		Attach(Player, Tool)
		Refresh()
		if getTeam() ~= Team then joinTeam(Team) end
		if findPlayer(Player.Name) then Log('[  ]: Gave '..Tool.Name..' to '..playerName(Player))
		else Log("[  ]: Couldn't give "..Tool.Name..' to '..playerName(Player)) end
	elseif findInStr({'food', 'foodtray', 'meal'}, Command) then
		local Obtained
		for _, v in next, giver:GetChildren() do
			if findInStr({'Breakfast', 'Lunch', 'Dinner'}, v.Name) then
				getTool(v.Name)
				Obtained = true
				if findInInv(v.Name) then Log('[  ]: Already obtained '..v.Name) break end
				Log('[  ] Obtained '..v.Name)
				break
			end
		end
		if not Obtained then Log("[  ]: Couldn't obtain any food item") end
	elseif findInStr({'key', 'keycard', 'card'}, Command) then
		if findInInv('Key card') then Log('[  ]: Already obtained Key card') return end
		getTool('Key card')
		Log('[  ] Obtained Key card')
	elseif findInStr({'findkey', 'findkeycard', 'findcard'}, Command) then
		if findInInv('Key card') then Log('[  ]: Already obtained Key card') return end
		if single:FindFirstChild('Key card') then
			getTool('Key card')
			Log('[  ] Found and obtained Key card')
			return
		end
		Powers.Keycard = true
		repeat wait() until single:FindFirstChild('Key card') or not Powers.Keycard
		if not Powers.Keycard then return end
		getTool('Key card')
		Powers.Keycard = false
		Log('[  ] Found and obtained Key card')
	elseif findInStr({'unkey', 'unkeycard', 'uncard'}, Command) then
		if not Powers.Keycard then Log('[  ]: Already stopped obtaining for Key card') return end
		Powers.Keycard = false
		Log('[  ]: Stopped obtaining for Key card')
	elseif findInStr({'crudeknife', 'knife'}, Command) then
		if findInInv('Crude Knife') then Log('[  ]: Already obtained Crude Knife') return end
		getTool('Crude Knife')
		Log('[  ] Obtained Crude Knife')
	elseif Command == 'Hammer' then
		if findInInv('Hammer') then Log('[  ]: Already obtained Hammer') return end
		getTool('Hammer')
		Log('[  ] Obtained Hammer')
	elseif findInStr({'shield', 'riotshield'}, Command) then
		if not Riot then Log('[  ]: You need to own the Riot Police gamepass to use this command') return end
		local Team = getTeam()
		local Guards = {}
		for _, Player in next, Players:GetPlayers() do
			if Player.TeamColor.Name == 'Bright blue' then table.insert(Guards, Player) end
		end
		if not findInStr({'Bright orange', 'Bright blue', 'Medium stone grey'}, Team) or #Guards > 8 then Log('[  ]: Cannot obtain Riot Shield') return end
		if findInInv('Riot Shield') then Log('[  ]: Already obtained Riot Shield') return end
		getTool('Riot Shield')
		if getTeam() ~= Team then joinTeam(Team) end
		Log('[  ] Obtained Riot Shield')
	elseif findInStr({'noshields', 'antishields'}, Command) then
		if Powers.NoShields then Log('[  ]: Already disabled shields from other players') return end
		Powers.NoShields = true
		Log('[  ]: Disabled shields from other players')
		repeat
			for _, Player in next, Players:GetPlayers() do
				if Player ~= User and Player.Character and Player.Character:FindFirstChild('Torso') then
					local Folder = Player.Character.Torso:FindFirstChild('ShieldFolder')
					if Folder and Folder:FindFirstChild('shield') then
						local Shield = Folder.shield
						Shield.Mesh.MeshId = ''
						Shield.Size = Vector3.new(0, 0, 0)
					end
				end
			end
			Run.RenderStepped:Wait()
		until not Powers.NoShields
	elseif findInStr({'shields', 'unantishields'}, Command) then
		if not Powers.NoShields then Log('[  ]: Already enabled shields from other players') return end
		Powers.NoShields = false
		Log('[  ]: Enabled shields from other players')
		for _, Player in next, Players:GetPlayers() do
			if Player ~= User and Player.Character and Player.Character:FindFirstChild('Torso') then
				local Folder = Player.Character.Torso:FindFirstChild('ShieldFolder')
				if Folder and Folder:FindFirstChild('shield') then
					local Shield = Folder.shield
					Shield.Mesh.MeshId = 'rbxassetid://82265009'
					Shield.Size = Vector3.new(2.6, 4.2, .4)
				end
			end
		end
	elseif findInStr(M9, Command) then
		if findInInv('M9') then Log('[  ]: Already obtained M9') return end
		getTool('M9')
		Log('[  ] Obtained M9')
	elseif findInStr(Remington, Command) then
		if findInInv('Remington 870') then Log('[  ]: Already obtained Remington 870') return end
		getTool('Remington 870')
		Log('[  ] Obtained Remington 870')
	elseif findInStr(AK47, Command) then
		if findInInv('AK-47') then Log('[  ]: Already obtained AK-47') return end
		getTool('AK-47')
		Log('[  ] Obtained AK-47')
	elseif findInStr(M4A1, Command) then
		if not Riot then Log('[  ]: You need to own the Riot Police gamepass to use this command') return end
		if findInInv('M4A1') then Log('[  ]: Already obtained M4A1') return end
		getTool('M4A1')
		Log('[  ] Obtained M4A1')
	elseif findInStr({'pp', 'penis', 'willy'}, Command) then
		if Powers.Penis then Log('[  ]: Already created a penis') return end
		Powers.Penis = true
		Log('[  ]: Created a penis')
		repeat
			local char = getChar()
			if char then
				local Tools = {'Remington 870', 'AK-47', 'M9', 'M4A1', 'Hammer', 'Crude Knife'}
				local Num = 0
				if not Riot then table.remove(Tools, 4) end
				for _, v in next, Tools do
					if not findInInv(v) then getTool(v) end
					local Tool = findInInv(v)
					if v == 'Remington 870' then Num = Tool.Handle.Size.Y * 5
					elseif v == 'AK-47' then Num = Num + (Tool.Handle.Size.Y * 23)
					elseif v == 'M4A1' then Num = Num + (Tool.Handle.Size.Y * 13)
					elseif v == 'Hammer' then 
						if Riot then Num = Num + (Tool.Handle.Size.Z * 8)
						else Num = Num + (Tool.Handle.Size.Z * 5) end
					elseif v == 'Crude Knife' then Num = Num + (Tool.Handle.Size.Z * 5)
					else Num = Num + (Tool.Handle.Size.Y * 15) end
					if findInStr({'Hammer', 'Crude Knife'}, v) then 
						Tool.Grip = CFrame.new(.9, -Num, 1.5) * CFrame.Angles(math.rad(90), 0, 0) 
					else Tool.Grip = CFrame.new(.9, 2, Num) end
					Tool.Parent = char
				end
			end
			Run.RenderStepped:Wait()
		until not Powers.Penis
	elseif findInStr({'nopp', 'nopenis', 'nowilly'}, Command) then
		if not Powers.Penis then Log('[  ]: Already removed penis') return end
		Powers.Penis = false
		local Tools = {'Remington 870', 'AK-47', 'M9', 'M4A1', 'Hammer', 'Crude Knife'}
		if not Riot then table.remove(Tools, 4) end
		for i, v in next, Tools do
			local Tool = findInInv(v)
			if Tool then
				Tool.Grip = CFrame.new(0, 0, 0)
				Tool.Parent = User.Backpack
			end
		end
		Log('[  ]: Removed penis')
	elseif findInStr({'guns', 'allguns'}, Command) then
		local Tools = {'Remington 870', 'AK-47', 'M9', 'M4A1'}
		local Got = 0
		if not Riot then table.remove(Tools, 4) end
		for _, v in next, Tools do
			if not findInInv(v) then
				getTool(v)
				Got = Got + 1
			end
		end
		if Got ~= 0 then Log('[  ]: Obtained all guns') else Log('[  ]: Already obtained all guns') end
	elseif findInStr({'autoguns', 'autoallguns'}, Command) then
		if Powers.AutoGuns then Log('[  ]: Already automatically obtaining all guns') return end
		local Tools = {'Remington 870', 'AK-47', 'M9', 'M4A1'}
		if not Riot then table.remove(Tools, 4) end
		Powers.AutoGuns = true
		Log('[  ]: Automatically obtaining all guns')
		repeat
			for _, v in next, Tools do
				if not findInInv(v) then getTool(v) end
			end
			Run.Heartbeat:Wait()
		until not Powers.AutoGuns
	elseif findInStr({'unautoguns', 'unautoallguns'}, Command) then
		if not Powers.AutoGuns then Log('[  ]: Already stopped automatically obtaining all guns') return end
		Powers.AutoGuns = false
		Log('[  ]: Stopped automatically obtaining all guns')
	elseif findInStr({'refreshgun', 'refgun', 'regun'}, Command) then
		if Args[1] then
			local Name
			if findInStr(M9, Args[1]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Name = 'Remington 870'
			elseif findInStr(AK47, Args[1]) then
				Name = 'AK-47'
			elseif findInStr(M4A1, Args[1]) then
				if not Riot then
					Log('[  ]: You need to own the Riot Police gamepass to refresh the M4A1')
					return
				end
				Name = 'M4A1'
			else 
				Log("[  ]: Couldn't find the gun to refresh")
			end
			if not Name then return end
			local char = getChar()
			if not char then Log("[  ]: Couldn't refresh the "..Name) return end
			local Tool = findInInv(Name)
			if not Tool then Log('[  ]: You do not have the '..Name..' in your inventory') return end
			refreshTool(Tool)
			Log('[  ]: Refreshed '..Name)
		end
	elseif findInStr({'refreshguns', 'refguns', 'reguns'}, Command) then
		local char = getChar()
		if not char then Log("[  ]: Couldn't refresh all guns") return end
		local Refreshed = 0
		local Tools = {'Remington 870', 'AK-47', 'M9', 'M4A1'}
		for _, v in next, Tools do
			local Tool = findInInv(v)
			if Tool then
				refreshTool(Tool)
				Refreshed = Refreshed + 1
			end
		end
		if Refreshed ~= 0 then Log('[  ]: Refreshed all guns') else Log('[  ]: No guns were found nor refreshed') end
	elseif findInStr({'firerate', 'gunspeed', 'firespeed'}, Command) then
		if Args[1] then
			local Name
			if findInStr(M9, Args[1]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Name = 'Remington 870'
			elseif findInStr(AK47, Args[1]) then
				Name = 'AK-47'
			elseif findInStr(M4A1, Args[1]) then
				if not Riot then
					Log('[  ]: You need to own the Riot Police gamepass to change the firerate for the M4A1')
					return
				end
				Name = 'M4A1'
			else 
				Log("[  ]: Couldn't find the gun to change the firerate for")
			end
			if not Name then return end
			if not Args[2] or not tonumber(Args[2]) then Log('[  ]: Input a number for the firerate') return end
			local char = getChar()
			if not char then Log("[  ]: Couldn't change the firerate for the "..Name) return end
			local Tool = findInInv(Name)
			if not Tool then Log('[  ]: You do not have the '..Name..' in your inventory') return end
			local newFR = tonumber(Args[2])
			local FR = require(Tool.GunStates).FireRate
			if newFR == FR then Log('[  ]: Already changed the firerate for the '..Name..' to'..Args[2]) return end
			require(Tool.GunStates).FireRate = newFR
			Log('[  ]: Changed the firerate for the '..Name..' to'..Args[2])
		end
	elseif findInStr({'automatic', 'autofire'}, Command) then
		if Args[1] then
			local Name
			if findInStr(M9, Args[1]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Name = 'Remington 870'
			else 
				Log("[  ]: Couldn't find the gun to enable autofire for")
			end
			if not Name then return end
			local char = getChar()
			if not char then Log("[  ]: Couldn't refresh the "..Name) return end
			local Tool = findInInv(Name)
			if not Tool then Log('[  ]: You do not have the '..Name..' in your inventory') return end
			if require(Tool.GunStates).AutoFire then Log('[  ]: Already enabled autofire for '..Name) return end
			require(Tool.GunStates).AutoFire = true
			Log('[  ]: Enabled autofire for '..Name)
		end
	elseif findInStr({'modgun', 'gunmods', 'gunmod'}, Command) then
		if Args[1] then
			local Name
			if findInStr(M9, Args[1]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Name = 'Remington 870'
			elseif findInStr(AK47, Args[1]) then
				Name = 'AK-47'
			elseif findInStr(M4A1, Args[1]) then
				if not Riot then
					Log('[  ]: You need to own the Riot Police gamepass to mod the M4A1')
					return
				end
				Name = 'M4A1'
			else 
				Log("[  ]: Couldn't find the gun to mod")
			end
			if Powers.ModdedGuns[Name] then Log('[  ]: Already modded '..Name) return end
			Powers.ModdedGuns[Name] = true
			Log('[  ]: Modded '..Name)
		end
	elseif findInStr({'unmodgun', 'ungunmods', 'ungunmod'}, Command) then
		if Args[1] then
			local Name
			if findInStr(M9, Args[1]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[1]) then
				Name = 'Remington 870'
			elseif findInStr(AK47, Args[1]) then
				Name = 'AK-47'
			elseif findInStr(M4A1, Args[1]) then
				if not Riot then
					Log('[  ]: You need to own the Riot Police gamepass to stop modding the M4A1')
					return
				end
				Name = 'M4A1'
			else 
				Log("[  ]: Couldn't find the gun to stop modding")
			end
			if not Powers.ModdedGuns[Name] then Log('[  ]: Already stopped modding '..Name) return end
			if Powers.ModAllGuns then Log('[  ]: You cannot stop modding '..Name) return end
			Powers.ModdedGuns[Name] = nil
			Log('[  ]: Stopped modding '..Name)
		end
	elseif findInStr({'modguns', 'modallguns'}, Command) then
		if Powers.ModAllGuns then Log('[  ]: Already modding all guns') return end
		local Tools = {'Remington 870', 'AK-47', 'M9', 'M4A1'}
		Powers.ModAllGuns = true
		Log('[  ]: Modding all guns')
		repeat
			for _, v in next, Tools do
				if not Powers.ModdedGuns[v] then Powers.ModdedGuns[v] = true end
			end
			wait(.1)
		until not Powers.ModAllGuns
		for _, v in next, Tools do
			if Powers.ModdedGuns[v] then Powers.ModdedGuns[v] = nil end
		end
	elseif findInStr({'unmodguns', 'unmodallguns'}, Command) then
		if not Powers.ModAllGuns then Log('[  ]: Already stopped modding all guns') return end
		Powers.ModAllGuns = false
		Log('[  ]: Stopped modding all guns')
	elseif Command == 'gate' then
		local dest = CFrame.new(492.763, 98.039917, 2216.74878)
		local name = 'in front of the gate'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif Command == 'opengate' then
		local part = workspace['Prison_Fences']['Prison_Gate'].damagePart
		if part.CFrame.Z ~= 2217.050048828125 then Log('[  ]: Gate already opened') return end
		itemEvt:InvokeServer(buttons['Prison Gate']['Prison Gate'])
		Log('[  ]: Opened gate')
	elseif Command == 'gateroom' then
		local dest = CFrame.new(504.324646, 102.039917, 2246.05103)
		local name = 'in the gate room'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif Command == 'gatetower' then
		local dest = CFrame.new(502.72168, 125.039917, 2321.00098)
		local name = 'on the gate tower'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'tower', 'yardtower'}, Command) then
		local dest = CFrame.new(823.014832, 130.039886, 2589.46802)
		local name = 'on the tower'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif Command == 'yard' then
		local dest = CFrame.new(780.596985, 97.9999237, 2468.43457)
		local name = 'on the yard'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'prison', 'nexus', 'nex'}, Command) then
		local dest = CFrame.new(915.108398, 99.9899826, 2378.2648)
		local name = 'in the prison'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'backnexus', 'backnex'}, Command) then
		local dest = CFrame.new(980.860535, 99.9899826, 2316.87769)
		local name = 'in the back nexus'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'armory', 'guardroom'}, Command) then
		local dest = CFrame.new(836.632568, 99.9899826, 2260.18994)
		local name = 'in the armory'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'cafeteria', 'cafe', 'lunchroom'}, Command) then
		local dest = CFrame.new(919.365601, 99.9899368, 2285.1748)
		local name = 'in the cafeteria'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'vendingmachine', 'foodmachine', 'machine'}, Command) then
		local machines = {CFrame.new(949, 101, 2340), CFrame.new(955, 101, 2340)}
		local dest = machines[math.random(1,2)]
		local name = 'in the vending machine'
		local char = getChar()
		if char then 
			if (machines[1].Position - getPos().Position).Magnitude <= 5 or (machines[2].Position - getPos().Position).Magnitude <= 5 then 
				Log('[  ]: Already teleported '..name) 
				return 
			end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'sewer', 'sewers'}, Command) then
		local dest = CFrame.new(916.570679, 78.7003937, 2323.39136)
		local name = 'in the sewers'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'roof', 'rooftop', 'prisontop'}, Command) then
		local roofs = {CFrame.new(917.232056, 139.926025, 2314.79761), CFrame.new(917.232056, 139.926025, 2459.79761)}
		local dest = roofs[math.random(1,2)]
		local name = 'on the roof'
		local char = getChar()
		if char then 
			if (roofs[1].Position - getPos().Position).Magnitude <= 5 or (roofs[2].Position - getPos().Position).Magnitude <= 5 then 
				Log('[  ]: Already teleported '..name) 
				return 
			end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'secretroom', 'unusedroom', 'modelsroom', 'library'}, Command) then
		local dest = CFrame.new(706, 103, 2344)
		local name = 'in the unused room'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'criminalbase', 'crimbase', 'base'}, Command) then
		local dest = CFrame.new(-943.724854, 94.1287613, 2064.69312)
		local name = 'in the criminal base'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'baseplate', 'neutralspawn'}, Command) then
		local dest = CFrame.new(880.4111328125, 27.78998565673828, 2349.805419921875)
		local name = 'on the baseplate'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
			local Pos = char:GetPivot()
			goTo(dest)
			if char:GetPivot() ~= Pos then  
				Log('[  ]: Teleported '..name)
			else Log("[  ]: Couldn't teleport "..name) end
		else Log("[  ]: Couldn't teleport "..name) end
	elseif findInStr({'traproom', 'trap'}, Command) then
		local dest = CFrame.new(-365.976562, 84.2401199, 1987.99207)
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					Bring(Player, dest)
					if findPlayer(Player.Name) then Log('[  ]: Trapped '..playerName(Player))
					else Log("[  ]: Couldn't trap "..playerName(Player)) end
				else execCmd('traproom', {}) end
			else Log('[  ]: No player found') end
		else 
			local name = 'in the trap room'
			local char = getChar()
			if char then 
				if (dest.Position - getPos().Position).Magnitude <= 5 then Log('[  ]: Already teleported '..name) return end
				local Pos = char:GetPivot()
				goTo(dest)
				if char:GetPivot() ~= Pos then  
					Log('[  ]: Teleported '..name)
				else Log("[  ]: Couldn't teleport "..name) end
			else Log("[  ]: Couldn't teleport "..name) end
		end
	elseif findInStr({'removevoid', 'antivoid', 'novoid'}, Command) then
		if workspace.FallenPartsDestroyHeight < -9999 then Log('[  ]: Already removed the void') return end
		workspace.FallenPartsDestroyHeight = -math.huge
		Log('[  ]: Removed the void')
	elseif findInStr({'restorevoid', 'unantivoid', 'void'}, Command) then
		if workspace.FallenPartsDestroyHeight == -500 then Log('[  ]: Already restored the void') return end
		workspace.FallenPartsDestroyHeight = -500
		Log('[  ]: Restored the void')
	elseif findInStr({'antiafk', 'antiidle', 'anti-idle'}, Command) then
		if Powers.AntiAFK then Log('[  ]: Already enabled anti-afk') return end
		Powers.AntiAFK = true
		Log('[  ]: Enabled anti-afk')
		local func; func = User.Idled:Connect(function()
			if not Powers.AntiAFK then func:Disconnect() return end
			VUS:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
			wait(1)
			VUS:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
		end)
	elseif findInStr({'unantiafk', 'unantiidle', 'unanti-idle'}, Command) then
		if not Powers.AntiAFK then Log('[  ]: Already disabled anti-afk') return end
		Powers.AntiAFK = false
		Log('[  ]: Disabled anti-afk')
	elseif findInStr({'rejoin', 'rj'}, Command) then
		Log('[  ]: Rejoining server')
		wait(.75)
		TPS:Teleport(game.PlaceId, User)
	elseif findInStr({'serverhop', 'shop'}, Command) then
		Log('[  ]: Joining a new server')
		wait(.75)
		local req = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
		if req then
			local servers = {}
			local url = req({Url = string.format('https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=Asc&limit=100', game.PlaceId)})
			local body = HttpSrv:JSONDecode(url.Body)
			if body and body.data then
				for _, v in next, body.data do
					if type(v) == 'table' and tonumber(v.playing) and tonumber(v.maxplrs) and v.playing < v.maxplrs and v.id ~= game.JobId then
						table.insert(servers, v.id)
					end 
				end
			end
			if #servers == 0 then TPS:Teleport(game.PlaceId) else TPS:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)], User) end
		else TPS:Teleport(game.PlaceId) end
	elseif Command == 'prefix' then
		if Args[1] then
			if #Args[1] > 1 or not Args[1]:match('%p') then Log('[  ]: Cannot set the prefix to <b>'..Prefix..'</b>', true) return end
			if Prefix == Args[1] then Log('[  ]: Already set the prefix to <b>'..Prefix..'</b>', true) return end
			Prefix = Args[1]
			HubSettings.Prefix = Args[1]
			saveSettings()
			Log('[  ]: Set the prefix to <b>'..Prefix..'</b>', true)
		else Log('[  ]: The prefix is set to <b>'..Prefix..'</b>', true) end
	elseif findInStr({'autoexecute', 'autoexec'}, Command) then
		if not (readfile and writefile and isfile) then 
			Log("[  ]: Your exploit doesn't support this command") 
			return 
		end
		local Return
		if Args[1] then
			local autoCmd
			if not Commands:FindFirstChild(Args[1]) then
				for _, v in next, Commands:GetChildren() do
					if autoCmd then break end
					if v:FindFirstChild('Aliases') then
						for _, v2 in next, v.Aliases:GetChildren() do 
							if v2.Value ~= Args[1] then continue end
							autoCmd = v
							break
						end
					end
				end
				if not autoCmd then
					Log('[  ]: Command <b>'..Args[1]..'</b> not found', true)
					Return = true 
				else 
					if findInStr({'autoexecute', 'unautoexecute'}, autoCmd.Name) then
						Log('[  ]: Cannot auto execute command <b>'..Args[1]..'</b>', true)
					end
					Return = true
				end
			else autoCmd = Commands[Args[1]] end
			if Return then return end
			local autoArgs = {}
			for i, v in next, Args do
				autoArgs[i] = v
			end
			table.remove(autoArgs, 1)
			if #autoArgs > 0 then
				if not autoCmd:FindFirstChild('Arguments') then
					Log('[  ]: Command <b>'..Args[1].."</b> doesn't have any arguments", true)
					Return = true
				else 
					local missing = 0
					local trueArgs = autoCmd.Arguments:GetChildren()
					if #autoArgs > #trueArgs then
						if #trueArgs == 1 then
							Log('[  ]: Command <b>'..Args[1]..'</b> only requires '..tostring(#trueArgs)..' argument', true)
						else
							Log('[  ]: Command <b>'..Args[1]..'</b> only requires '..tostring(#trueArgs)..' arguments', true)
						end
						Return = true
					else 
						for i, v in next, trueArgs do
							if not autoArgs[i] and v.Name == 'Required' then
								missing = missing + 1
							end
						end
						if missing > 0 then
							if missing == 1 then
								Log('[  ]: Missing '..tostring(missing)..' required argument for Command <b>'..Args[1]..'</b>', true)
							else
								Log('[  ]: Missing '..tostring(missing)..' required arguments for Command <b>'..Args[1]..'</b>', true)
							end
							Return = true
						end
					end
				end
			elseif autoCmd:FindFirstChild('Arguments') then
				local missing = 0
				local trueArgs = autoCmd.Arguments:GetChildren()
				for i, v in next, trueArgs do
					if not autoArgs[i] and v.Name == 'Required' then
						missing = missing + 1
					end
				end
				if missing > 0 then
					if missing == 1 then
						Log('[  ]: Missing '..tostring(missing)..' required argument for Command <b>'..Args[1]..'</b>', true)
					else
						Log('[  ]: Missing '..tostring(missing)..' required arguments for Command <b>'..Args[1]..'</b>', true)
					end
					Return = true
				end
			end
			if Return then return end
			local alreadyCmd = HubSettings.AutoExecute[autoCmd.Name] or nil
			if alreadyCmd and #alreadyCmd == #autoArgs then
				if #autoArgs == 0 then 
					Log('[  ]: Already auto executing Command <b>'..Args[1]..'</b> on new servers', true)
					Return = true
					return
				end
				local same = 0
				for i, v in next, alreadyCmd do
					if autoArgs[i] == v then same = same + 1 end
				end
				if same == #alreadyCmd then
					if #autoArgs == 1 then
						Log('[  ]: Already auto executing Command <b>'..Args[1]..'</b> with '..tostring(#autoArgs)..' argument on new servers', true) 
					else 
						Log('[  ]: Already auto executing Command <b>'..Args[1]..'</b> with '..tostring(#autoArgs)..' arguments on new servers', true) 
					end
					Return = true
					return
				end
			end
			if Return then return end
			HubSettings.AutoExecute[autoCmd.Name] = autoArgs
			saveSettings()
			if #autoArgs == 0 then 
				Log('[  ]: Auto executing Command <b>'..Args[1]..'</b> on new servers', true)
			elseif #autoArgs == 1 then
				Log('[  ]: Auto executing Command <b>'..Args[1]..'</b> with '..tostring(#autoArgs)..' argument on new servers', true) 
			else 
				Log('[  ]: Auto executing Command <b>'..Args[1]..'</b> with '..tostring(#autoArgs)..' arguments on new servers', true) 
				return 
			end
		end
	elseif findInStr({'unautoexecute', 'unautoexec'}, Command) then
		if not (readfile and writefile and isfile) then 
			Log("[  ]: Your exploit doesn't support this command") 
			return 
		end
		local Return
		if Args[1] then
			local autoCmd
			if not Commands:FindFirstChild(Args[1]) then
				for _, v in next, Commands:GetChildren() do
					if autoCmd then break end
					if v:FindFirstChild('Aliases') then
						for _, v2 in next, v.Aliases:GetChildren() do 
							if v2.Value ~= Args[1] then continue end
							autoCmd = v
							break
						end
					end
				end
				if not autoCmd then
					Log('[  ]: Command <b>'..Args[1]..'</b> not found', true)
					Return = true 
				end
			else autoCmd = Commands[Args[1]] end
			if Return then return end
			if not HubSettings.AutoExecute[autoCmd.Name] then
				Log('[  ]: Already stopped auto executing Command <b>'..Args[1]..'</b>', true)
				return
			end
			HubSettings.AutoExecute[autoCmd.Name] = nil
			saveSettings()
			Log('[  ]: Stopped auto executing Command <b>'..Args[1]..'</b>', true)
		end
	elseif findInStr({'autoexecuted', 'autoexecutes', 'autoexecs'}, Command) then
		if not (readfile and writefile and isfile) then 
			Log("[  ]: Your exploit doesn't support this command") 
			return 
		end
		local str
		for cmd, args in next, HubSettings.AutoExecute do
			if not (cmd or args) then continue end
			local argsStr
			for _, v in next, args do 
				if not argsStr then argsStr = v else argsStr = argsStr..', '..v end
			end
			if argsStr then
				if not str then str = ' '..cmd..': '..argsStr else str = str..'\n '..cmd..': '..argsStr end
			else 
				if not str then str = ' '..cmd else str = str..'\n '..cmd end
			end
		end
		if str then
			Log('[  ]: Auto executed commands:\n'..str)
		else Log('[  ]: No commands are being auto executed') end
	end
end
-->>> Creating player commands
local PlayerCmds = {
	{name = 'info', args = {'cmd'}, desc = 'Chats a description of the command'},
	{name = 'cmds', aliases = {'commands'}, desc = 'Chats a list of available commands'},
	{name = 'tase', aliases = {'taze'}, args = {'plr | team | all', true}, desc = 'Tases the player, team, or all players once'},
	{name = 'looptase', aliases = {'looptaze'}, args = {'plr | team | all', true}, desc = 'Tases the player, team, or all players in a loop'},
	{name = 'unlooptase', aliases = {'unlooptaze'}, args = {'plr | team | all', true}, desc = 'Stops tasing the player, team, or all players in a loop'},
	{name = 'eliminate', aliases = {'elim', 'kill'}, args = {'plr | team | all', true}, desc = 'Eliminates the player, team, or all players once'},
	{name = 'loopelim', aliases = {'loopkill', 'lkill', 'lk', 'loopeliminate'}, args = {'plr | team | all', true}, desc = 'Eliminates the player, team, or all players in a loop'},
	{name = 'unloopelim', aliases = {'unloopkill', 'unlkill', 'unlk', 'ulk', 'unloopeliminate'}, args = {'plr | team | all', true}, desc = 'Stops eliminating the player, team, or all players in a loop'},
	{name = 'aura', aliases = {'killaura'}, args = {'plr, range'}, desc = 'Eliminates players on a range near of you'},
	{name = 'noaura', aliases = {'nokillaura', 'unkillaura', 'unaura'}, args = {'plr, range'}, desc = 'Stops eliminating players on a range near of you'},
	{name = 'criminal', aliases = {'criminals', 'crims', 'crim'}, desc = 'Makes you join the Criminals team'},
	{name = 'makecrim', aliases = {'makecriminal'}, args = {'plr | team |all', true}, desc = 'Makes the player, team, or all players join the Criminals team'},
	{name = 'goto', aliases = {'to'}, args = {'plr', true}, desc = 'Teleports you to the player'},
	{name = 'bring', args = {'plr', true}, desc = 'Brings the player to your position'},
	{name = 'fling', args = {'plr', true}, desc = 'Flings the player out of the map'},
	{name = 'give', aliases = {'givetool', 'giveitem', 'attach'}, args = {'me | plr, tool', true}, desc = 'Gives you or the player the item'},
	{name = 'gate', desc = 'Teleports you in front of the gate'},
	{name = 'opengate', desc = 'Opens the gate'},
	{name = 'gateroom', desc = 'Teleports you in the gate room'},
	{name = 'gatetower', desc = 'Teleports you on the tower beside the gate'},
	{name = 'tower', aliases = {'yardtower'}, desc = 'Teleports you on the tower beside the yard'},
	{name = 'yard', desc = 'Teleports you on the yard'},
	{name = 'prison', aliases = {'nexus', 'nex'}, desc = 'Teleports you in the prison'},
	{name = 'backnex', aliases = {'backnexus'}, desc = 'Teleports you in the back nexus'},
	{name = 'armory', aliases = {'guardroom'}, desc = 'Teleports you in the armory'},
	{name = 'cafe', aliases = {'cafeteria', 'lunchroom'}, desc = 'Teleports you in the cafeteria'},
	{name = 'machine', aliases = {'vendingmachine', 'foodmachine'}, desc = 'Teleports you in a vending machine'},
	{name = 'sewers', aliases = {'sewer'}, desc = 'Teleports you in the sewers'},
	{name = 'roof', aliases = {'rooftop', 'prisontop'}, desc = 'Teleports you on the roof of the prison'},
	{name = 'secretroom', aliases = {'unusedroom', 'modelsroom', 'library'}, desc = 'Teleports you in an unused room'},
	{name = 'crimbase', aliases = {'criminalbase', 'base'}, desc = 'Teleports you in the criminal base'},
	{name = 'baseplate', aliases = {'neutralspawn'}, desc = 'Teleports you on the baseplate under the map'},
	{name = 'trap', aliases = {'traproom'}, args = {'plr'}, desc = 'Teleports you or the player in the trap room'},
}
-->>> Creating player command functions
local function execPlayerCmd(Speaker, Command, Args)
	if findInStr({'commands', 'cmds'}, Command) then
		local str = '[  ]: Commands, Prefix is '..Prefix..' | '
		for i, v in next, PlayerCmds do
			if v.name == 'cmds' then continue end
			local add = v.name..' | '
			str = str..add
			if i == #PlayerCmds then 
				str = str:sub(1, #str - 3)
				Chat(str, Speaker)
			elseif #str > 176 then
				str = str:sub(1, #str - (#add + 3))
				Chat(str, Speaker)
				str = ''
				wait(.1)
			end
		end
	elseif Command == 'info' then
		if Args[1] then
			local infoCmd
			for _, v in next, PlayerCmds do
				if v.name == Args[1] then
					infoCmd = v
					break
				else
					if v.aliases then
						for _, v2 in next, v.aliases do 
							if v2 == Args[1] then 
								infoCmd = v 
								break
							end
						end
						if infoCmd then break end
					end
				end
			end
			if not infoCmd then
				Chat('[  ]: Command "'..Args[1]..'" not found', Speaker)
				return
			end
			local str = infoCmd.name
			if infoCmd.args then 
				if infoCmd.args[2] then str = str..' ('..infoCmd.args[1]..')'
				else str = str..' ['..infoCmd.args[1]..']' end
			end
			str = str..': '..infoCmd.desc
			Chat('[  ]: '..str,Speaker)
		end
	elseif findInStr({'tase', 'taze'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				local allowed
				if not findInInv('Taser') then
					joinTeam('Bright blue', true)
					wait(.25)
					local Team = getTeam()
					if Team ~= 'Bright blue' then Chat("[  ]: Couldn't tase all players", Speaker) 
					else 
						Refresh()
						if findInStr({'Bright orange', 'Medium stone grey'}, Team) then teamEvt(Team) end
						allowed = true 
					end
				else allowed = true end
				if allowed then
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then Tase(Tased) end
					Chat('[  ]: Tased all players', Speaker)
				end
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= Speaker then
						if Player == User then Chat('[  ]: Tsk tsk tsk... no tasing me', Speaker) return end
						local allowed
						if not findInInv('Taser') then
							joinTeam('Bright blue', true)
							wait(.25)
							local Team = getTeam()
							if Team ~= 'Bright blue' then Chat("[  ]: Couldn't tase "..playerName(Player), Speaker) 
							else 
								Refresh()
								if findInStr({'Bright orange', 'Medium stone grey'}, Team) then teamEvt(Team) end
								allowed = true 
							end
						else allowed = true end
						if allowed then
							Tase(Player)
							Chat('[  ]: Tased '..playerName(Player), Speaker)
						end
					else Chat('[  ]: You cannot tase yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
			if targetTeam then
				local allowed
				if not findInInv('Taser') then
					joinTeam('Bright blue', true)
					wait(.25)
					local Team = getTeam()
					if Team ~= 'Bright blue' then Chat("[  ]: Couldn't tase "..targetTeam[2], Speaker) 
					else 
						Refresh()
						if findInStr({'Bright orange', 'Medium stone grey'}, Team) then teamEvt(Team) end
						allowed = true 
					end
				else allowed = true end
				if allowed then
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit and Player.TeamColor.Name == targetTeam[1] then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then Tase(Tased) end
					Chat('[  ]: Tased '..targetTeam[2], Speaker)
				end
			end
		end
	elseif findInStr({'looptase', 'looptaze'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if Powers.LoopTaseAll then Chat('[  ]: Already loop tasing all players', Speaker) return end
				Powers.LoopTaseAll = true
				Chat('[  ]: Loop tasing all players', Speaker)
				repeat
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and not Player.Character.Humanoid.Sit then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then
						if not findInInv('Taser') then
							joinTeam('Bright blue', true)
						end
						Tase(Tased)
					end
					wait(1)
				until not Powers.LoopTaseAll
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= Speaker then
						if Player == User then Chat('[  ]: Tsk tsk tsk... no loop tasing me', Speaker) return end
						if Powers.LoopTased[Player.Name] then Chat('[  ]: Already loop tasing '..playerName(Player), Speaker) return end
						Powers.LoopTased[Player.Name] = true
						Chat('[  ]: Loop tasing '..playerName(Player), Speaker)
					else Chat('[  ]: You cannot loop tase yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
			if targetTeam then
				if Powers['LoopTase'..targetTeam[2]] then Chat('[  ]: Already loop tasing '..targetTeam[2], Speaker) return end
				Powers['LoopTase'..targetTeam[2]] = true
				Chat('[  ]: Loop tasing '..targetTeam[2], Speaker)
				repeat
					local Tased = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.TeamColor.Name == targetTeam[1] then
							table.insert(Tased, Player)
						end
					end
					if #Tased > 0 then
						if not findInInv('Taser') then
							joinTeam('Bright blue', true)
						end
						Tase(Tased)
					end
					wait(1)
				until not Powers['LoopTase'..targetTeam[2]]
			end
		end
	elseif findInStr({'unlooptase', 'unlooptaze'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if not Powers.LoopTaseAll then Chat('[  ]: Already stopped loop tasing all players', Speaker) return end
				Powers.LoopTaseAll = false
				Chat('[  ]: Stopped loop tasing all players', Speaker)
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= User then
						if Player == User then Chat("[  ]: You can't even loop tase me anyways", Speaker) return end
						if not Powers.LoopTased[Player.Name] then Chat('[  ]: Already stopped loop tasing '..playerName(Player), Speaker) return end
						Powers.LoopTased[Player.Name] = nil
						Chat('[  ]: Stopped loop tasing '..playerName(Player), Speaker)
					else Chat('[  ]: You cannot stop loop tasing yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
			if targetTeam then
				if not Powers['LoopTase'..targetTeam[2]] then Chat('[  ]: Already stopped loop tasing '..targetTeam[2], true) return end
				Powers['LoopTase'..targetTeam[2]] = nil
				Chat('[  ]: Stopped loop tasing '..targetTeam[2], Speaker)
			end
		end
	elseif Command == 'arrest' then
		if Args[1] then
			if findInStr(Crims, Args[1]) then 
				local Pos = getPos()
				local Arrested = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Head') and not Player.Character.Head:FindFirstChild('handcuffedGui') and Player.TeamColor.Name == 'Really red' then
						local char = getChar()
						if not char or not char:FindFirstChild('Humanoid') or char.Humanoid.Health == 0 then Respawn() end
						Arrest(Player)
						Arrested = Arrested + 1 
					end
				end
				goTo(Pos)
				if not Speaker or findPlayer(Speaker.Name) then return end
				if Arrested == 0 then Chat('[  ]: No Criminals were arrested', Speaker) return end
				Chat('[  ]: Arrested Criminals', Speaker)
			elseif findInStr(AllPlayers, Args[1]) then
				local Pos = getPos()
				local Arrested = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Head') and not Player.Character.Head:FindFirstChild('handcuffedGui') and findInStr({'Really red', 'Bright orange'}, Player.TeamColor.Name) then
						local char = getChar()
						if not char or not char:FindFirstChild('Humanoid') or char.Humanoid.Health == 0 then Respawn() end
						Arrest(Player)
						if Player.Character.Head:FindFirstChild('handcuffedGui') then Arrested = Arrested + 1 end
					end
				end
				goTo(Pos)
				if not Speaker or findPlayer(Speaker.Name) then return end
				if Arrested == 0 then Chat('[  ]: No players were arrested', Speaker) return end
				Chat('[  ]: Arrested all players', Speaker)
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= Speaker then
						if Player == User then Chat('[  ]: Tsk tsk tsk... no arresting me', Speaker) return end
						if Player.TeamColor.Name == 'Really red' and (Player.Character and Player.Character:FindFirstChild('Head')) then
							if Player.Character.Head:FindFirstChild('handcuffedGui') then Chat('[  ] '..playerName(Player)..' is already arrested', Speaker) return end
							local Pos = getPos()
							local char = getChar()
							if not char or not char:FindFirstChild('Humanoid') or char.Humanoid.Health == 0 then Respawn() end
							Arrest(Player)
							goTo(Pos)
							if not Speaker or findPlayer(Speaker.Name) then return end
							Chat('[  ]: Arrested '..playerName(Player), Speaker)
						else Chat("[  ]: Couldn't arrest "..playerName(Player), Speaker) end
					else Chat('[  ]: You cannot arrest yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
		end
	elseif findInStr({'kill', 'eliminate', 'elim'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				local Killed = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') then
						table.insert(Killed, Player)
					end
				end
				local Team = getTeam()
				if #Killed > 0 then 
					if findInStr({'Bright orange', 'Bright blue', 'Really red'}, Team) then joinTeam('Medium stone grey') end
					Kill(Killed) 
				end
				if getTeam() ~= Team then joinTeam(Team) end
				Chat('[  ]: Eliminated all players', Speaker)
			else
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= Speaker then
						if Player == User then Chat('[  ]: Tsk tsk tsk... no eliminating me', Speaker) return end
						if not(Player.Character and Player.Character:FindFirstChild('Humanoid')) or Player.Character.Humanoid.Health == 0 or Player.Character:FindFirstChild('ForceField') then
							Chat("[  ]: Couldn't eliminate "..playerName(Player), Speaker)
							return
						end
						local Team = getTeam()
						if Player.TeamColor.Name == Team then joinTeam('Medium stone grey') end
						Kill(Player)
						if getTeam() ~= Team then joinTeam(Team) end
						Chat('[  ]: Eliminate '..playerName(Player), Speaker)
					else Chat('[  ]: You cannot eliminate yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
			if targetTeam then
				local Killed = {}
				for _, Player in next, Players:GetPlayers() do
					if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') and Player.TeamColor.Name == targetTeam[1] then
						table.insert(Killed, Player)
					end
				end
				local Team = getTeam()
				if #Killed > 0 then 
					if targetTeam[1] == Team then joinTeam('Medium stone grey') end
					Kill(Killed) 
				end
				if getTeam() ~= Team then joinTeam(Team) end
				Chat('[  ]: Killed '..targetTeam[2], Speaker)
			end
		end
	elseif findInStr({'loopkill', 'lkill', 'lk', 'loopeliminate', 'loopelim'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= Speaker then
						if Player == User then Chat('[  ]: Tsk tsk tsk... no loop eliminating me', Speaker) return end
						if Powers.LoopKilled[Player.Name] then Chat('[  ]: Already loop eliminating '..playerName(Player), Speaker) return end
						if getTeam() == Player.TeamColor.Name then Chat('[  ]: Cannot loop eliminate '..playerName(Player), Speaker) return end
						Powers.LoopKilled[Player.Name] = {Enabled = true, Safe = true}
						Chat('[  ]: Loop eliminating '..playerName(Player), Speaker)
					else Chat('[  ]: You cannot loop eliminate yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
			if targetTeam then
				if Powers['LoopKill'..targetTeam[2]] then Chat('[  ]: Already loop eliminating '..targetTeam[2], Speaker) return end
				Powers['LoopKill'..targetTeam[2]] = true
				Chat('[  ]: Loop eliminating '..targetTeam[2], Speaker)
				repeat
					local Killed = {}
					for _, Player in next, Players:GetPlayers() do
						if Player ~= User and Player ~= Speaker and not Whitelist[Player.Name] and Player.Character and Player.Character:FindFirstChild('Humanoid') and Player.Character.Humanoid.Health > 0 and not Player.Character:FindFirstChild('ForceField') and Player.TeamColor.Name == targetTeam[1] then
							table.insert(Killed, Player)
						end
					end
					if #Killed > 0 then
						local Team = getTeam()
						if targetTeam[1] == Team then joinTeam('Medium stone grey') end
						Kill(Killed)
					end
					wait(1)
				until not Powers['LoopKill'..targetTeam[2]]
			end
		end
	elseif findInStr({'unloopkill', 'unlkill', 'unlk', 'ulk', 'unloopeliminate', 'unloopelim'}, Command) then
		if Args[1] then
			local targetTeam
			if findInStr(Inmates, Args[1]) then 
				targetTeam = {'Bright orange', 'Inmates'}
			elseif findInStr(Guards, Args[1]) then 
				targetTeam = {'Bright blue', 'Guards'}
			elseif findInStr(Crims, Args[1]) then 
				targetTeam = {'Really red', 'Criminals'}
			elseif findInStr(AllPlayers, Args[1]) then
				if not Powers.LoopKillAll then Chat('[  ]: Already stopped loop eliminating all players', Speaker) return end
				Powers.LoopKillAll = false
				Chat('[  ]: Stopped loop eliminating all players', Speaker)
			else 
				local Player = findPlayer(Args[1])
				if Player then
					if Player ~= Speaker then
						if Player == User then Chat("[  ]: You can't even loop eliminate me anyways", Speaker) return end
						if not Powers.LoopKilled[Player.Name] then Chat('[  ]: Already stopped loop eliminating '..playerName(Player), Speaker) return end
						Powers.LoopKilled[Player.Name] = nil
						Chat('[  ]: Stopped loop eliminating '..playerName(Player), Speaker)
					else Chat('[  ]: You cannot stop loop eliminating yourself', Speaker) end
				else Chat('[  ]: No player found', Speaker) end
			end
			if targetTeam then
				if not Powers['LoopKill'..targetTeam[2]] then Chat('[  ]: Already stopped loop eliminating '..targetTeam[2], Speaker) return end
				Powers['LoopKill'..targetTeam[2]] = false
				Chat('[  ]: Stopped loop eliminating '..targetTeam[2], Speaker)
			end
		end
	elseif findInStr({'killaura', 'aura'}, Command) then
		local Return
		local Self
		local Player
		local Range
		if Args[1] then
			local num = tonumber(Args[1])
			if num then 
				if num <= 0 or num > 100 then
					Chat('[  ]: Type a valid kill aura range from 1-100', Speaker)
					Return = true
					return
				end
				Range = num 
				Player = Speaker
			else
				Player = findPlayer(Args[1])
				if not Player then 
					Chat('[  ]: No player found', Speaker)
					Return = true
				elseif Player == User then 
					Chat('[  ]: I decide when I want a kill aura', Speaker)
					Return = true
					return
				end
			end
		else Player = Speaker end
		if Return then return end
		if Args[2] then
			if Range then
				Return = true 
				return
			else 
				local num = tonumber(Args[1])
				if num then Range = num else 
					Chat('[  ]: Type a valid kill aura range', true)
					Return = true
				end
			end
		end
		if Return then return end
		if not Powers.Aura[Player.Name] or not Powers.Aura[Player.Name].Enabled then
			Powers.Aura[Player.Name] = {Enabled = true, Range = Range or 20}
			if Player ~= Speaker then
				Chat('[  ]: Enabled kill aura for '..playerName(Player), Speaker)
			else Chat('[  ]: Enabled kill aura', Speaker) end
			if Range then 
				if Player ~= Speaker then
					Chat('[  ]: Set kill aura range for '..playerName(Player)..' to '..tostring(Range), Speaker) 
				else Chat('[  ]: Set kill aura range to '..tostring(Range), Speaker) end
			end	
		else 
			if Range then
				if Powers.Aura[Player.Name].Range == Range then 
					if Player ~= Speaker then
						Chat('[  ]: Already set kill aura range for '..playerName(Player)..' to '..tostring(Range), Speaker) 
					else Chat('[  ]: Already set kill aura range to '..tostring(Range), Speaker) end
					return 
				end
				Powers.Aura[Player.Name].Range = Range
				if Player ~= Speaker then
					Chat('[  ]: Set kill aura range for '..playerName(Player)..' to '..tostring(Range), Speaker) 
				else Chat('[  ]: Set kill aura range to '..tostring(Range), Speaker) end
			else 
				if Player ~= Speaker then
					Chat('[  ]: Already enabled kill aura for '..playerName(Player), Speaker) 
				else Chat('[  ]: Already enabled kill aura', Speaker) end
			end
		end
	elseif findInStr({'nokillaura', 'unkillaura', 'noaura', 'unaura'}, Command) then
		local Self
		local Player
		local Return
		if Args[1] then
			Player = findPlayer(Args[1])
			if not Player then 
				Chat('[  ]: No player found', Speaker)
				Return = true
			elseif Player == User then 
				Chat("[  ]: I decide when I don't want a kill aura", Speaker)
				Return = true
			end 
		else Player = Speaker end
		if Return then return end
		if not Powers.Aura[Player.Name] or not Powers.Aura[Player.Name].Enabled then 
			if Player ~= Speaker then
				Chat('[  ]: Already disabled kill aura for '..playerName(Player), Speaker) 
			else Chat('[  ]: Already disabled kill aura', Speaker) end
			return 
		end
		Powers.Aura[Player.Name].Enabled = false
		if Player ~= Speaker then
			Chat('[  ]: Disabled kill aura for '..playerName(Player), Speaker)
		else Chat('[  ]: Disabled kill aura', Speaker) end
	elseif findInStr(Crims, Command) and #Args == 0 then
		local Team = Speaker.TeamColor.Name
		if Team == 'Really red' then Chat('[  ]: Already joined Criminals team', Speaker) return end
		MakeCrim(Speaker)
		if not Speaker or findPlayer(Speaker.Name) then return end
		Chat('[  ]: Joined Criminals team', Speaker)
	elseif findInStr({'makecriminal', 'makecrim', 'criminal', 'crim'}, Command) then
		if Args[1] then
			local Team = getTeam()
			local Pos = getPos()
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= Speaker then
					if Player == User then Chat('[  ]: I decide when I want to be a criminal', Speaker) end
					MakeCrim(Player)
					if getTeam() ~= Team then joinTeam(Team) end
					goTo(Pos)
					if not Player or not findPlayer(Player.Name) or Player.TeamColor.Name ~= 'Really red' then
						Chat("  ]: Couldn't make "..playerName(Player)..' a criminal', Speaker)
						return
					end
					if not Speaker or findPlayer(Speaker.Name) then return end
					Chat('[  ]: Made '..playerName(Player)..' a criminal', Speaker)
				else execPlayerCmd('criminal', {}) end
			else Chat('[  ]: No player found', Speaker) end
		end
	elseif findInStr({'goto', 'to'}, Command) then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= Speaker then
					local char = Speaker.Character
					local plrChar = Player.Character
					if not char or not plrChar then Chat("[  ]: Couldn't teleport to "..playerName(Player), Speaker) return end
					local Pos = char:GetPivot()
					Bring(Speaker, plrChar.HumanoidRootPart.Position)
					if not Speaker or findPlayer(Speaker.Name) then return end
					if char:GetPivot() == Pos then Chat("[  ]: Couldn't teleport to "..playerName(Player), Speaker) return end
					Chat('[  ]: Teleported to '..playerName(Player), Speaker)
				else Chat('[  ]: You cannot teleport to yourself', Speaker) end
			else Chat('[  ]: No player found', Speaker) end
		end
	elseif Command == 'bring' then
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= Speaker then
					if Player == User then Chat('[  ]: I decide when I want to be brought', Speaker) end
					Bring(Player, Speaker.Character.HumanoidRootPart.Position)
					if not Speaker or findPlayer(Speaker.Name) then return end
					if findPlayer(Player.Name) then Chat('[  ]: Brought '..playerName(Player), Speaker)
					else Chat("[  ]: Couldn't bring "..playerName(Player), Speaker) end
				else Chat('[  ]: You cannot bring yourself', Speaker) end
			else Chat('[  ]: No player found', Speaker) end
		end
	elseif Command == 'fling' then
		if Args[1] then
			local Pos = getPos()
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= Speaker then
					if Player == User then Chat('[  ]: Tsk tsk tsk... no flinging me', Speaker) return end
					Powers.Fling = true
					Fling(Player)
					Respawn()
					goTo(Pos)
					Powers.Fling = false
					if not Speaker or findPlayer(Speaker.Name) then return end
					Chat('[  ]: Flung '..playerName(Player), Speaker)
				else Chat('[  ]: You cannot fling yourself', Speaker) end
			else Chat('[  ]: No player found', Speaker) end
		end
	elseif findInStr({'give', 'givetool', 'giveitem', 'attach'}, Command) then
		local Team = getTeam()
		local Player
		local Tool
		local Return
		if Args[1] then
			if not findInStr({'me', 'myself'}, Args[1]) then 
				Player = findPlayer(Args[1])
				if not Player then 
					Chat('[  ]: No player found', Speaker) 
					Return = true
				elseif Player == User then 
					Chat('[  ]: I decide when I want stuff', Speaker)
					Return = true
				end
			else Player = Speaker end
		else Return = true end
		if Return then return end
		if Args[2] then
			local Name
			if findInStr(M9, Args[2]) then
				Name = 'M9'
			elseif findInStr(Remington, Args[2]) then
				Name = 'Remington 870'
			elseif findInStr(AK47, Args[2]) then
				Name = 'AK-47'
			elseif findInStr(M4A1, Args[2]) and Riot then
				Name = 'M4A1'
			elseif findInStr({'taser', 'tazer'}, Args[2]) then
				Name = 'Taser'
			elseif Args[2] == 'hammer' then
				Name = 'Hammer'
			elseif findInStr({'crudeknife', 'knife'}, Args[2]) then
				Name = 'Crude Knife'
			elseif findInStr({'handcuffs', 'cuffs'}, Args[2]) then
				Name = 'Handcuffs'
			elseif findInStr({'shield', 'riotshield'}, Args[2])  and Riot then
				Name = 'Riot Shield'
			elseif findInStr({'key', 'keycard', 'card'}, Args[2]) then
				Name = 'Key card'
			elseif Args[2] == 'breakfast' then
				Name = 'Breakfast'
			elseif Args[2] == 'lunch' then
				Name = 'Lunch'
			elseif Args[2] == 'dinner' then
				Name = 'Dinner'
			else 
				Chat("[  ]: Couldn't find the item to give", Speaker)
				Return = true
			end
			if Return then return end 
			if not findInInv(Name) then
				if findInStr({'Taser', 'Handcuffs'}, Name) then
					joinTeam('Bright blue', true)
				else
					if findInStr({'Breakfast', 'Lunch', 'Dinner'}, Name) and not giver:FindFirstChild(Name) then 
						if Player ~= Speaker then
							Chat('[  ]: Cannot give '..Name..' to '..playerName(Player), Speaker) 
						else Chat('[  ]: Cannot obtain '..Name, Speaker) end
						Return = true
					end
					if Return then return end
					getTool(Name)
				end
			end
			Tool = findInInv(Name)
		end
		if Return then return end
		Attach(Player, Tool)
		Refresh()
		if getTeam() ~= Team then joinTeam(Team) end
		if not Speaker or findPlayer(Speaker.Name) then return end
		if Player ~= Speaker then
			if findPlayer(Player.Name) then Chat('[  ]: Gave '..Tool.Name..' to '..playerName(Player), Speaker)
			else Chat("[  ]: Couldn't give "..Tool.Name..' to '..playerName(Player), Speaker) end
		else Chat('[  ]: Obtained '..Tool.Name, Speaker) end
	elseif Command == 'gate' then
		local dest = CFrame.new(492.763, 98.039917, 2216.74878)
		local name = 'in front of the gate'
		local char = Speaker.Character
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif Command == 'opengate' then
		local part = workspace['Prison_Fences']['Prison_Gate'].damagePart
		if part.CFrame.Z ~= 2217.050048828125 then Chat('[  ]: Gate already opened', Speaker) return end
		itemEvt:InvokeServer(buttons['Prison Gate']['Prison Gate'])
		Chat('[  ]: Opened gate', Speaker)
	elseif Command == 'gateroom' then
		local dest = CFrame.new(504.324646, 102.039917, 2246.05103)
		local name = 'in the gate room'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif Command == 'gatetower' then
		local dest = CFrame.new(502.72168, 125.039917, 2321.00098)
		local name = 'on the gate tower'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'tower', 'yardtower'}, Command) then
		local dest = CFrame.new(823.014832, 130.039886, 2589.46802)
		local name = 'on the tower'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif Command == 'yard' then
		local dest = CFrame.new(780.596985, 97.9999237, 2468.43457)
		local name = 'on the yard'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'prison', 'nexus', 'nex'}, Command) then
		local dest = CFrame.new(915.108398, 99.9899826, 2378.2648)
		local name = 'in the prison'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'armory', 'guardroom'}, Command) then
		local dest = CFrame.new(836.632568, 99.9899826, 2260.18994)
		local name = 'in the armory'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'backnexus', 'backnex'}, Command) then
		local dest = CFrame.new(980.860535, 99.9899826, 2316.87769)
		local name = 'in the back nexus'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'sewer', 'sewers'}, Command) then
		local dest = CFrame.new(916.570679, 78.7003937, 2323.39136)
		local name = 'in the sewers'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'cafeteria', 'cafe', 'lunchroom'}, Command) then
		local dest = CFrame.new(919.365601, 99.9899368, 2285.1748)
		local name = 'in the cafeteria'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'vendingmachine', 'foodmachine', 'machine'}, Command) then
		local machines = {CFrame.new(949, 101, 2340), CFrame.new(955, 101, 2340)}
		local dest = machines[math.random(1,2)]
		local name = 'in the vending machine'
		local char = getChar()
		if char then 
			if (machines[1].Position - getPos().Position).Magnitude <= 5 or (machines[2].Position - getPos().Position).Magnitude <= 5 then 
				Chat('[  ]: Already teleported '..name, Speaker) 
				return 
			end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'roof', 'rooftop', 'prisontop'}, Command) then
		local roofs = {CFrame.new(917.232056, 139.926025, 2314.79761), CFrame.new(917.232056, 139.926025, 2459.79761)}
		local dest = roofs[math.random(1,2)]
		local name = 'on the roof'
		local char = getChar()
		if char then 
			if (roofs[1].Position - getPos().Position).Magnitude <= 5 or (roofs[2].Position - getPos().Position).Magnitude <= 5 then 
				Chat('[  ]: Already teleported '..name, Speaker) 
				return 
			end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'secretroom', 'unusedroom', 'modelsroom', 'library'}, Command) then
		local dest = CFrame.new(706, 103, 2344)
		local name = 'in the unused room'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'criminalbase', 'crimbase', 'base'}, Command) then
		local dest = CFrame.new(-943.724854, 94.1287613, 2064.69312)
		local name = 'in the criminal base'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'baseplate', 'neutralspawn'}, Command) then
		local dest = CFrame.new(880.4111328125, 27.78998565673828, 2349.805419921875)
		local name = 'on the baseplate'
		local char = getChar()
		if char then 
			if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
			local Pos = char:GetPivot()
			Bring(Speaker, dest)
			if char:GetPivot() ~= Pos then  
				Chat('[  ]: Teleported '..name, Speaker)
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		else Chat("[  ]: Couldn't teleport "..name, Speaker) end
	elseif findInStr({'traproom', 'trap'}, Command) then
		local dest = CFrame.new(-365.976562, 84.2401199, 1987.99207)
		if Args[1] then
			local Player = findPlayer(Args[1])
			if Player then
				if Player ~= User then
					Bring(Player, dest)
					if findPlayer(Player.Name) then Chat('[  ]: Trapped '..playerName(Player), Speaker)
					else Chat("[  ]: Couldn't trap "..playerName(Player), Speaker) end
				else execCmd('traproom', {}) end
			else Chat('[  ]: No player found', Speaker) end
		else 
			local name = 'in the trap room'
			local char = getChar()
			if char then 
				if (dest.Position - getPos().Position).Magnitude <= 5 then Chat('[  ]: Already teleported '..name, Speaker) return end
				local Pos = char:GetPivot()
				Bring(Speaker, dest)
				if char:GetPivot() ~= Pos then  
					Chat('[  ]: Teleported '..name, Speaker)
				else Chat("[  ]: Couldn't teleport "..name, Speaker) end
			else Chat("[  ]: Couldn't teleport "..name, Speaker) end
		end
	end
end
-->>> Commands from search bar
hubFunc(SearchBar.FocusLost:Connect(function(e)
	if e and Tabs:GetAttribute('CurrentTab') == 'Admin' then
		local args = SearchBar.Text:lower():split(' ')
		local cmd = args[1]
		table.remove(args, 1)
		SearchBar.Text = ''
		execCmd(cmd, args)
	end
end))
-->>> Commands from chat
hubFunc(ChatEvt.OnMessageDoneFiltering.OnClientEvent:Connect(function(d)
	local Player = Players:FindFirstChild(d.FromSpeaker)
	local msg = d.Message:lower()
	local Pf = string.match(msg, '^%s*(.)')
	if Pf == Prefix then
		local args = msg:gsub('%'..Prefix, ''):split(' ')
		local cmd = args[1]
		table.remove(args, 1)
		if Player == User and Tabs:GetAttribute('CurrentTab') == 'Admin' then
			execCmd(cmd, args)
		elseif Ranked[Player.Name] then
			execPlayerCmd(Player, cmd, args)
		end
	end
end))
--\\
--// After script loads
CPS:PreloadAsync(YmirHub:GetChildren())
YmirHub.Enabled = true
if HubSettings.SplitScreen then
	wait(.5)
	Tabs:SetAttribute('SplitScreen', true)
end
Log('[  ]: Loaded script')
--\\
--// Other functions
spawn(function() 
	for i, v in next, HubSettings.AutoExecute do
		spawn(function() execCmd(i, v) end)
	end
end)

spawn(function() 
	for _, Player in next, Players:GetPlayers() do
		if Ranked[Player.Name] then
			Chat('[  ]: You have been ranked as admin. To view commands, chat '..Prefix..'cmds', Player)
		end
	end
end)

hubFunc(Players.PlayerAdded:Connect(function(Player) 
	if Ranked[Player.Name] then
		local loaded
		local func; func = Player.CharacterAdded:Connect(function(char)
			CPS:PreloadAsync(char:GetChildren())
			Chat('[  ]: You have been ranked as admin. To view commands, chat '..Prefix..'cmds', Player)
			if loaded then func:Disconnect() else loaded = true end
		end)
	end
end))

hubFunc(YmirHub:GetPropertyChangedSignal('Parent'):Connect(function()
	if YmirHub.Parent == nil then
		Ranked = {}
		Whitelist = {}
		Powers = {}
		for _, v in next, HubFunctions do v:Disconnect() end
	end
end))

hubFunc(Run.Heartbeat:Connect(function()
	pcall(function()
		local char = getChar()
		if char then
			local CIH = char:FindFirstChild('ClientInputHandler')
			if CIH and CIH.Enabled then
				local handler = getsenv(CIH).cs
				if handler.isFighting then
					if Powers.FastPunch or Powers.SuperPunch then handler.isFighting = false end
					if Powers.OnePunch or Powers.SuperPunch then touchKill() end
				end
			end
		end
	end)
end))

spawn(function()
	while true do
		if YmirHub.Parent == nil then break end
		local Tased = {}
		for i, _ in next, Powers.LoopTased do
			local Player = findPlayer(i)
			if Player then
				table.insert(Tased, Player)
			end
		end
		if #Tased > 0 then
			if not findInInv('Taser') then
				joinTeam('Bright blue', true)
			end
			Tase(Tased)
		end
		wait(1)
	end
end)

spawn(function()
	while true do
		if YmirHub.Parent == nil then break end
		local Killed = {}
		for i, v in next, Powers.LoopKilled do
			local Player = findPlayer(i)
			if Player and v.Enabled then
				local Team = getTeam()
				if Player.TeamColor.Name == Team then 
					if v.Safe then continue else joinTeam('Medium stone grey') end
				end
				table.insert(Killed, Player)
			end
		end
		if #Killed > 0 then
			Kill(Killed)
		end
		wait(1)
	end
end)

hubFunc(Run.Heartbeat:Connect(function()
	local Killed = {}
	for i, v in next, Powers.Aura do
		local Player = findPlayer(i)
		if Player and Player.Character and Player.Character:FindFirstChild('HumanoidRootPart') and v.Enabled then
			pcall(function()
				for _, v2 in next, Players:GetPlayers() do
					if v2 ~= User and v2 ~= Player and not Whitelist[v2.Name] and v2.Character and v2.Character:FindFirstChild('Humanoid') and v2.Character.Humanoid.Health > 0 and not v2.Character:FindFirstChild('ForceField') then
						local dist = (v2.Character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).Magnitude
						if dist <= v.Range then
							local Team = getTeam()
							if v2.TeamColor.Name == Team then joinTeam('Medium stone grey') end
							table.insert(Killed, v2)
						end
					end
				end
			end)
		end
	end
	if #Killed > 0 then
		Kill(Killed)
	end
end))

hubFunc(Run.Heartbeat:Connect(function()
	for name, _ in next, Powers.ModdedGuns do
		local char = getChar()
		local Tool = findInInv(name)
		if char and Tool and not Tool:GetAttribute('Modded') then
			local states = require(Tool.GunStates)
			states.Range = 1000
			states.Damage = math.huge
			states.FireRate = -math.huge
			states.ReloadTime = -math.huge
			states.AutoFire = true
			Tool:SetAttribute('Modded', true)
			if states.CurrentAmmo <= 0 then
				local Parent = Tool.Parent
				Tool.Handle:Destroy()
				Tool.Parent = char
				Tool:Destroy()
				getTool(name)
				local newTool = findInInv(name)
				newTool.Parent = Parent
			end
		end
	end
end))
